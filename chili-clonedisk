#!/usr/bin/env bash

#  clonedisk - utility written in bash to clone disks
#  ChiliLinux GNU/Linux - https://github.com/vcatafesta/ChiliOS
#  ChiliLinux GNU/Linux - https://chililinux.com
#  ChiliLinux GNU/Linux - https://chilios.com.br
#
#  Created: 2019/04/05
#  Altered: 2022/04/07
#
#  Copyright (c) 2019-2022, Vilmar Catafesta <vcatafesta@gmail.com>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

#  fetch uses quite a few external programs during its execution. You
#  need to have at least the following installed for makepkg to function:
#     awk, bsdtar (libarchive), bzip2, coreutils, fakeroot, file, find (findutils),
#     gettext, gpg, grep, gzip, sed, tput (ncurses), xz
#  contains portion of software https://bananapkg.github.io/
#########################################################################
#set -e
declare -r APP="${0##*/}"
declare -r _APP_="chili-clonedisk"
declare -r _VERSION_="v2.0.3-20220407"
readonly DEPENDENCIES=(which lsblk cut dialog whiptail pv grep sed cat awk tput dd)

# Import lib
LIBRARY=${LIBRARY:-'/usr/share/fetch'}
SYSCONFDIR=${SYSCONFDIR:-'/etc/fetch'}
[ -r "${LIBRARY}"/core.sh ] && source "${LIBRARY}"/core.sh

sh_configure()
{

	#DIALOG=${DIALOG:-"whiptail"}
	DIALOG=${DIALOG:-"dialog"}

	# common vars
	grafico=$true
	xapp="Chili GNU/Linux CloneDisk"
	ccabec="${xapp} $_VERSION_"
	ctitle="$cdistro Linux"
	welcome="Welcome to the $xapp"
	xkernel=$(uname -n)

	# flag dialog exit status codes
	: ${D_OK=0}
	: ${D_CANCEL=1}
	: ${D_HELP=2}
	: ${D_EXTRA=3}
	: ${D_ITEM_HELP=4}
	: ${D_ESC=255}

	# vars bool
	DIAHORA=`date +"%d%m%Y-%T" | sed 's/://g'`
	trancarstderr=2>&-
	true=0 TRUE=0 OK=0 ok=0
	false=1 FALSE=1 NOK=1 nok=1 falso=1 CANCEL=1
	HEIGHT=0 WIDTH=0
	ESC=255

	# flag para disco/particao/formatacao/montagem
	: ${LDISK=0}
	: ${LPARTITION=0}
	: ${LFORMAT=0}
	: ${LMOUNT=0}
	: ${TARSUCCESS=$false}
	: ${STANDALONE=$false}
	: ${STARTXFCE4=$true}
	: ${xUUIDSWAP=""}
	: ${xPARTSWAP=""}
	: ${xPARTEFI=""}
	: ${lEFI=$false}
	: ${LGRUB="EFI"}
	: ${LAUTOMATICA=$false}
	: ${xLABEL=$cdistro}

	# choosedisk
	: ${ARRAY_DSK_DEVICES=()}
	: ${ARRAY_DSK_DISKS=()}
	: ${ARRAY_DSK_SIZE=()}
	: ${ARRAY_DSK_MODEL=()}
	: ${ARRAY_DSK_TRAN=()}
	: ${ARRAY_DSK_LABEL=()}
}

replicate(){
	for counter in $(seq 1 $2);
   do
   	printf "%s" $1
   done
}

sh_disk_info()
{
	ARRAY_DSK_DISKS=($(lsblk -a -P -o TYPE,NAME,PATH,NAME,SIZE,MODEL | awk '$0~/disk/{print $2}' | sed 's/[NAME=*\"]//g'))
	ARRAY_DSK_DEVICES=($(lsblk -a -P -o TYPE,NAME,PATH,NAME,SIZE,MODEL | awk '$0~/disk/{print $3}' | sed 's/[PATH=*\"]//g'))
	ARRAY_DSK_SIZE=($(lsblk -a -P -o TYPE,NAME,PATH,NAME,SIZE,MODEL | awk '$0~/disk/{print $5}' | sed 's/[SIZE=*\"]//g'))
	ARRAY_DSK_MODEL=($(lsblk -a -P -o TYPE,MODEL | egrep "disk" | cut -d'"' -f4- | sed 's/"//g'| sed 's/[[:space:]]\+/_/g'| awk '{print "["$0"]"}'))
   ARRAY_DSK_TRAN=($(lsblk -a -P -o TRAN,TYPE,MODEL | egrep "disk" | cut -d'"' -f2 | awk '{print "["$0"]"}'))
   ARRAY_DSK_LABEL=($(lsblk -a -P -o LABEL,TYPE,MODEL | egrep "disk" | cut -d'"' -f2))
}

DOT()
{
	printf "${blue}:: ${reset}"
	return
}

arraylen()
{
	for item in ${array[*]}
	do
		printf "   %s\n" $item
	done
	arraylength=${"$1"[*]}
}

is_true()
{
	[ "$1" = "1" ] || [ "$1" = "yes" ] || [ "$1" = "true" ] ||  [ "$1" = "y" ] || [ "$1" = "t" ]
}

sh_trapErro()
{
	${DIALOG} --msgbox "Voce pressionou ctrl-c" 7 60
}

confirma()
{
	[ "$1" -ne 0 ] && { conf "INFO" "$2"; return $?;}
}

msg()
{
	if [ $grafico -eq $true ]; then
        ${DIALOG}           \
        --no-collapse       \
        --title     "$1"    \
        --infobox   "\n$2"  \
        6 60
    else
        log_info_msg "$2"
    fi
}

mensagem()
{
	${DIALOG}                	\
		--title 		"$ctitle"  	\
		--backtitle	"$ccabec"	\
		--infobox 	"$*"        \
    	6 60
}

tolower()
{
	$1 | tr 'A-Z' 'a-z'
}

toupper()
{
	$1 | tr 'a-z' 'Z-A'
}

display_result()
{
	local xbacktitle=$ccabec

	if [ "$3" != "" ] ; then
		xbacktitle="$3"
	fi

	${DIALOG}							\
		--title 		"$2"				\
		--beep                     \
		--no-collapse					\
		--no-cr-wrap               \
		--backtitle	"$xbacktitle"	\
		--msgbox 	"$1" 				\
		0 0
}

alerta()
{
	${DIALOG}							      \
		--colors			 			     		\
		--title 		"$1" 			     		\
		--no-collapse							\
		--cr-wrap    		           		\
		--backtitle	"$ccabec"		      \
		--msgbox 	"\Z2$2\n\Z1$3\n\Z3$4\n\Z4$5\n\Z5$6"	\
		0 0
}

info()
{
	${DIALOG}  	 				   \
		--colors                \
		--beep                  \
		--title 		"$cmsg002"	\
		--backtitle	"$ccabec"	\
		--msgbox 	"\Z1$*"		\
		10 60
}

conf()
{
	xtitle="$1"
	shift
	${DIALOG}							\
		--title 		"$xtitle" 		\
		--backtitle	"$ccabec"		\
		--yes-label "$yeslabel"		\
		--no-label  "$nolabel"		\
		--yesno 		"$*" 				\
		0 0
		return $?
}

confmulti()
{
	xtitle="$1"
	shift
	${DIALOG}						\
		--title 		"$xtitle"	\
		--backtitle	"$ccabec"	\
		--yes-label "$yeslabel"	\
		--no-label  "$nolabel"	\
		--yesno 		"$*"			\
		10 100
		return $?
}

quit()
{
	[ $? -ne 0 ] && { clear ; exit ;}
}

sh_checkdisk()
{
	local nchoice=0
	dsk=$(df -h | grep "$sddest" | awk '{print $1, $2, $3, $4, $5, $6, $7}')
	if [ "$dsk" <> " " ]; then
		conf "$cwarning" "\n$cmsg_all_mounted_part\n\n$dsk\n\n$cmsg_dismount"
		nchoice=$?
		if [ $nchoice = 0 ]; then
			for i in $(seq 1 10); do
				umount -f -rl $sddest$i 2> /dev/null
			done
		fi
	fi
	return $nchoice
}

size_to_human(){
   awk -v size="$1" '
   BEGIN {
      suffix[1] = "B"
      suffix[2] = "KiB"
      suffix[3] = "MiB"
      suffix[4] = "GiB"
      suffix[5] = "TiB"
      suffix[6] = "PiB"
      suffix[7] = "EiB"
      count = 1

      while (size > 1024) {
         size /= 1024
         count++
      }

      sizestr = sprintf("%.2f", size)
      sub(/\.?0+$/, "", sizestr)
      printf("%s %s", sizestr, suffix[count])
   }'
}

now()
{
	DIAHORA=`date +"%d%m%Y-%T" | sed 's/://g'`
	printf "%s\n" $DIAHORA
}

sh_backup_partitions()
{
	local disk="${1}"
	local device="${2}"
	local cdatetime=$(now)
	local tmpdir="/tmp/$_APP_"
	local filetmp="$tmpdir/${device}.$cdatetime.dump"

	mkdir -p $tmpdir 2> /dev/null
	sfdisk -d $disk > $filetmp 2> /dev/null
#	alerta "BACKUP DA TABELA DE PARTICOES" 	\
#			 "Dispositivo : $disk" 					\
#			 "  Backup on : ${filetmp}"			\
#			"$(replicate "=" 80)" 					\
#			 "$(cat $filetmp)"
}

sh_restore_partitions()
{
	sfdisk $sd < /tmp/sda.dump
}

choosedisk()
{
	while true
	do
		sh_disk_info

    	LDISK=0
		local xmsg=$cmsg_disco_origem
		local arr=()
		local array=()
#		local devices=()
		local i=0
		local x=0
		local y=0
		local t=0
		local z=0
		local n=0
		local nc=0
		for i in ${ARRAY_DSK_DEVICES[@]}
		do
#			devices[((n++))]="/dev/$i"
#			array[((n++))]="[${tran[((t++))]}] [${size[((x++))]}]  ${model[((y++))]}"
			a=${ARRAY_DSK_TRAN[$nc]}
			b=${ARRAY_DSK_SIZE[$nc]}
			c=${ARRAY_DSK_MODEL[$nc]}
			d=${ARRAY_DSK_LABEL[$nc]}
			[[ $a = "[]" ]] && a="[blk]"
			[[ $b = "[]" ]] && b="[unknown]"
			[[ $c = "[]" ]] && c="[unknown]"
			[[ $d = "[]" ]] && d="[unknown]"
			array[((n++))]="$i"
			array[((n++))]=$(printf "%-6s|%6s|%-30s|%s" $a $b $c $d)
			((nc++))
		done

    	sd=$(${DIALOG} 	 																			\
    				--title 			"$xmsg"					  			  							\
    				--backtitle	 	"$ccabec"				   									\
					--ok-label		"$cmsg_select" 												\
    				--cancel-label "$buttonback"													\
    				--colors																				\
    				--extra-button																		\
    				--extra-label  "$buttonpart"													\
    				--menu 			"\n$cmsg009" 0 0 0 "${array[@]}" 2>&1 >/dev/tty 	)

    	exit_status=$?
    	case $exit_status in
			$ESC)
    			init
    			;;
    		$CANCEL)
    			init
    			;;
    		3)
         	local result=$( fdisk -l $sd );
    			display_result "$result" "$csmg013" "$cmsg_part_disk"
    			continue
    			;;
    	esac

    	if [ "$1" = "SEE" ] ; then
    		local result=$( fdisk -l $sddest )
    		display_result "$result" "$csmg013" "$cmsg_part_disk"
    		continue
    	fi

    	if [ $sd != "" ]; then
			{	local item
            index=0
            for item in ${ARRAY_DSK_DEVICES[*]}
            do
            	[ $item = $sd ] && { break; }
               ((index++))
            done
			}
			DEVICE_ORIGEM="${ARRAY_DSK_DISKS[index]}"
			MODEL_ORIGEM="$sd [${ARRAY_DSK_SIZE[index]}] [${ARRAY_DSK_MODEL[index]}]"
			TRAN_ORIGEM="${ARRAY_DSK_TRAN[index]}"
			sh_backup_partitions "${sd}" "${DEVICE_ORIGEM}"
			choosediskdestin
    	fi
    	break
    done
}

choosediskdestin()
{
	while true
	do
#		sh_disk_info

    	LDISK=0
		local xmsg=$cmsg_disco_destino
		local array=()
#		local devices=()
		local i=0
		local x=0
		local y=0
		local t=0
		local z=0
		local n=0
		for i in ${ARRAY_DSK_DEVICES[@]}
		do
#			devices[((n++))]="/dev/$i"
#			array[((n++))]="/dev/$i"
#			array[((n++))]="$i"
#			array[((n++))]="[${size[((x++))]}]  ${model[((y++))]}"
			[[ "${i}" = "${sd}" ]] && continue
			array[((n++))]="$i"
			a=${ARRAY_DSK_TRAN[((x++))]}
			b=${ARRAY_DSK_SIZE[((y++))]}
			c=${ARRAY_DSK_MODEL[((t++))]}
			d=${ARRAY_DSK_LABEL[((z++))]}
			[[ $d = "" ]] && d=""
			array[((n++))]=$(printf "%-4s|%6s|%-30s|%s" $a $b $c $d)
		done

    	sddest=$(${DIALOG}	 																		\
    				--title 			"$xmsg"	  			  			  							   \
    				--backtitle	 	"$ccabec"					 									\
					--ok-label		"$cmsgOK"	 													\
    				--cancel-label "$buttonback"													\
    				--extra-button																		\
    				--extra-label  "$buttonpart"													\
    				--menu 			"\nSOURCE DISK: $MODEL_ORIGEM\n\n$cmsgdest" 0 0 0 "${array[@]}" 2>&1 >/dev/tty 	)

    	exit_status=$?
    	case $exit_status in
			$ESC)
    			init
    			;;
    		$CANCEL)
    			choosedisk
    			;;
    		3)
         	local result=$( fdisk -l $sd );
    			display_result "$result" "$csmg013" "$cmsg_part_disk"
    			continue
    			;;
    	esac

    	if [ "$1" = "SEE" ] ; then
    		local result=$( fdisk -l $sddest )
    		display_result "$result" "$csmg013" "$cmsg_part_disk"
    		continue
    	fi

    	if [ $sddest != "" ]; then
			{	local item
            index=0
            for item in ${ARRAY_DSK_DEVICES[*]}
            do
            	[ $item = $sddest ] && { break; }
               ((index++))
            done
			}

			DEVICE_DESTINO="${ARRAY_DSK_DISKS[index]}"
			MODEL_DESTINO="$sddest [${ARRAY_DSK_SIZE[index]}] [${ARRAY_DSK_MODEL[index]}]"
			TRAN_DESTINO="${ARRAY_DSK_TRAN[index]}"

	    	if [ $sd == $sddest ]; then
				alerta " *** WARWING *** " "\n   \Z1$cmsgDiscoIdem \n\n      \Z4SOURCE DISK : \Z1\Zr$MODEL_ORIGEM\ZR\n \Z4DISK DESTINATION : \Z1\Zr$MODEL_DESTINO\ZR"
				init
				return
			fi
			sh_backup_partitions "${sddest}" "${DEVICE_DESTINO}"
			sh_checkdisk
			local nmontada=$?
			if [ $nmontada = 1 ]; then
				alerta "CHOOSEDISK" "$cmsg_nec_dismount"
			fi
			sh_confclone
		fi
		break
    done
}

sh_domakeclone()
{
	LFORMAT=0
	mensagem "$cmsg_Formatando_particao: $sd TO $sddest"
	(pv -n $sd | 												\
	dd of=$sddest conv=notrunc,noerror,sync) 2>&1 |	\
	${DIALOG} --gauge 										\
	"Running cloning dd command (dd if=$sd of=$sddest conv=notrunc,noerror,sync), please wait...\n\n     SOURCE DISK : $MODEL_ORIGEM \n DISK DESTINATION: $MODEL_DESTINO" 10 84 0
	local nchoice=$?
	if [ $nchoice = $true ]; then
		display_result "$(fdisk -l $sddest)"
		LFORMAT=1
   fi
	return $nchoice
}

sh_confclone()
{
	conf 	" *** WARNING *** " 								\
			"\n$cmsgTodos_os_dados_serao_perdidos\n" 	\
			"${MODEL_DESTINO}" 								\
			"\n\n       SOURCE DISK: $MODEL_ORIGEM \n  DISK DESTINATION: $MODEL_DESTINO" \
			"\n\n" 																								\
     		"Continuar com o clone?\n"

	format=$?
	if [ $format = 0 ] ; then
		sh_domakeclone
	fi
	return $format
}

pt_BR()
{
	langmsg=(
		'lang=("pt BR" "en_US")'
		'cmsgErro=("ERRO" "ERROR")'
		'buttonback=("Voltar" "Back")'
		'buttonpart=("Info disco" "Disk info")'
		'cmsgNaoEncontreiOComando=("não encontrei o comando" "I did not find the command")'
		'cMsgEsseScriptPrecisaDosComandosListadosAcima=("Esse script precisa dos comandos listados acima" "This script needs the commands listed above")'
  	 	'cmsgInstaleOuVerifique=("Instale-os e/ou verifique se estão no seu \$PATH" "Install them and/or check if they are on your \$PATH")'
		'cmsgOK=("Ok","Ok")'
		'cmsg000=("Sair","Exit")'
		'cmsg_select=("Selecionar", "Select")'
	)

	for xmsg in "${langmsg[@]}"; do eval $xmsg; done
#	echo "lang      ${#lang[@]} ${lang[@]} ${lang[0]} ${lang[1]}"
#	echo "cmsgerror ${#cmsgerror[@]} ${cmsgerror[@]} ${cmsgerror[0]} ${cmsgerror[1]}"

	lang=('pt_BR' 'pt_BR')
  	cmsgErro=('ERRO' 'ERRO')
	buttonback="Voltar"
	buttonpart="Info disco"
  	cmsgNaoEncontreiOComando="não encontrei o comando "
  	cmsgEsseScriptPrecisaDosComandosListadosAcima="Esse script precisa dos comandos listados acima"
   cmsgInstaleOuVerifique="Instale-os e/ou verifique se estão no seu \$PATH"
	cmsgOK="Ok"
	cmsg000="Sair"
	cmsg_select="Selecionar"
	cmsg001=$ccabec
	cmsg002=$ctitle
	cmsg003="Bem-vindo ao instalador do $cdistro"
	cmsg004="Escolha uma opção:"
	cmsgBaixar_pacote_de_instalacao="Baixar pacote de instalacao"
	cmsg006="Particionar Disco"
	cmsg007="Escolha partição"
	cmsg008="Sair do instalador"
	cmsgquit="Sair do instalador"
	cmsg009="Escolha o disco de ORIGEM:"
	cmsgdest="Escolha o disco de DESTINO:"
	cmsg010="Escolha o tipo:"
	cmsg011="Particionamento manual usando cfdisk"
	cmsg012="Experiente"
	cexpert="Experiente"
	cnewbie="Novato"
	cmsg013="Particionamento automatico (sfdisk)"
	cmsg014="Tem certeza?"
	cmsg015="A versão mínima não inclui o Xorg e DE.\nVocê gostaria de baixar o $cdistro minimal?"
	cmsg016="Você gostaria de baixar o $cdistro full?"
	cmsg017='Download cancelado!'
	cancelinst="Instalacao cancelada!"
	cancelbind="Chroot cancelado!"
	cmsgversion=$cmsg015
	cmsg018="Baixar pacote full (X)"
	cmsg019="Baixar pacote minimal"
	cmsgTodos_os_dados_serao_perdidos="** AVISO ** Todos os dados disco DESTINO abaixo serão perdidos!"
	cmsg021="Formatar partição"
	menuquit="Sair"
	menustep="Passo a passo"
	yeslabel="Sim"
	nolabel="Não"
	cdlok1="*** DOWNLOAD *** "
	cdlok2="\n[OK] Download concluído com sucesso."
	cdlok3="encontrado."
	cdlok4="\n\nIniciar a instalação agora?"
	cshaok="\n[OK] Checksum verificado com sucesso."
   plswait="Por favor aguarde, baixando pacote..."
	cfinish="Instalação completa!\nReboot para iniciar com $cdistro Linux.\n\nBugs? $xemail"
	cgrubsuccess="GRUB instalado com sucesso!"
	ccancelgrub="Instalação do GRUB cancelada!"
	cmsgInstalar_GRUB="Instalar GRUB"
	cmsgAlterar_FSTAB="Alterar FSTAB"
	cinitbind="Iniciar BIND"
	cconfuser="Configurar usuario e senha"
	cconfusernow="Configurar usuário e senha agora"
	ccreatenewuser="Criar um novo usuário"
	cGrubMsgInstall="Você gostaria de instalar o GRUB?"
	cchooseX="Escolha o seu ambiente de Desktop"
	cxfce4="Clássico e poderoso!"
	ci3wm="Desktop para caras avançados B)."
	cmsgmin="Instalação mínima, sem X"
	cmsgfull="Instalação completa. *8.2G de disco (Xfce4 ou i3wm)"
	cwgeterro0="Sem problemas"
	cwgeterro1="Erro genérico"
	cwgeterro2="Erro de parse"
	cwgeterro3="Erro de I/IO no arquivo"
	cwgeterro4="Falha na rede"
	cwgeterro5="Falha na verificação do certificado SSL"
	cwgeterro6="Falha na autenticação (usuário ou senha)"
	cwgeterro7="Erro de protocolo"
	cwgeterro8="Servidor enviou uma respostar de erro"
	cerrotar0="Sucesso"
	cerrotar1="Árvore de diretório ruim, não conseguiu extrair um arquivo solicitado, \
   			   \narquivo de entrada igual ao arquivo de saída, falha ao abrir o arquivo de entrada, \
			   \nnão foi possível criar um  link, tabela link  malloc  falhouSucesso"
	cerrotar2="Erro de internacionalização que nunca deveria ocorrer, erro de checksum"
	cerrotar5="Erro de checksum"
	cerrotar9="(EBADF) - Erro lendo /etc/default/tar, fim de volume mal colocado"
	cerrotar12="(ENOMEM) – falha na alocação de memória para buffer"
	cerrotar22="(EINVAL) – invocação ruim (erros de sintaxe do arqumento),\
                \nparâmetros ruins para opções(ENOMEM) – falha na alocação de memória para buffer"
	cerrotar28="(ENOSPC) – arquivo muito grande para um volume"
	cerrotar78="(ENAMETOOLONG) - cwd name muito longo"
	cerrotar171="(ETOAST) – unidade de fitas on fire"
	ctools="Ferramentas/Configurações"
	cmsgtestarota="Aguarde, testando rota para o servidor $cdistro..."
	cmsgdelsha256="Aguarde, excluindo SHA256SUM antigo..."
	cmsgusermanager="Gerenciamento de usuários $cdistro Linux"
	cmsgPacotes_disponiveis="Pacotes disponiveis"
	cmsggetshasum="Aguarde, baixando sha256sum novo..."
	cmsgdelpackageindex="Aguarde, excluindo indice antigo..."
   cmsgdeltarball="Aguarde, excluindo tarball antigo..."
   cmsgtestsha256sum="Aguarde, testando sha256sum"
	cmsgadduser="Aguarde, criando usuario..."
	cmsgaddhost="Aguarde, setando hostname..."
   cmsgerrotar="Erro na descompatacao do pacote"
	cmsgwaitgrub="Aguarde, instalando o GRUB no disco"
	cmsgnoroute="Ops, sem rota para o servidor da $cdistro!\nVerifique sua internet."
	cmsgerrodlsha1="Ops, erro no download de !\nVerifique sua internet."
	cmsgerrodlsha2="Verifique sua internet."
	cmsgcorrdlnew="Ops, Pacote ou SHA256 corrompido. \nBaixar novamente o pacote?"
	cmsg_corr_rep="Ops, Pacote ou SHA256 corrompido. \nFavor repetir a operação!"
	cmsg_erro_tar_continue="Erro na descompactação do pacote. \nDeseja ainda prosseguir?"
	cmsg_all_ready="Tudo pronto para iniciar a instalação. Confirma?"
   cmsg_wget_package_index="Aguarde, baixando indice dos pacotes..."
	cmsg_nec_dismount="Necessário desmontar particao para reparticionar automaticamente."
	cwarning="** AVISO **"
	cmsg_alert_mount="Só para lembrar que o disco contém partições montadas."
	cmsgA_particao_esta_montada="A partição está montada"
	cmsg_dismount="Desmontar?"
	cmsg_all_mounted_part="O disco selecionado contém partições montadas."
	cmsg_umount_partition="Aguarde, Desmontando particao de trabalho."
	cmsg_create_dir="Aguarde, criando diretorio de trabalho."
	cmsg_mount_partition="Aguarde, Montando particao de trabalho."
	cmsg_try_mount_partition="Particao já montada. Tentar?"
	cmsg_mount_failed="Falha de montagem da partição. Repetir?"
	cmsg_enter_work_dir="Aguarde, Entrando no diretorio de trabalho."
	cmsg_mkfs_ok="Formatacao terminada com sucesso."
	cmsg_mkfs_error="Erro na Formatacao."
	cdisco="DISCO"
	cmsg_disco_origem="DISCO DE ORIGEM"
	cmsg_disco_destino="DISCO DE DESTINO"
	cparticao="PARTIÇÃO"
	cmsg_extracting="Aguarde, extraindo arquivos..."
	cmsg_part_disk="Visualizar partições do disco"
	cmsg_prepare_disk="Aguarde, preparando o disco:"
   cmsg_install_grub_disk="Instalando GRUB no disco"
   cmsg_Detectada_particao_EFI="Detectada partição EFI"
   cmsg_Deseja_instalar_o_GRUB_EFI="Deseja instalar o GRUB EFI"
   cmsg_Sim_EFI="Sim=EFI"
   cmsg_Nao_MBR="Não=MBR"
   cmsg_Desmontando_particao="Desmontando partição"
   cmsg_Formatando_particao="Formatando partição"
   cmsg_Montando_particao="Montando partição"
   cmsg_Instalando_GRUB_EFI_na_particao="Instalando GRUB EFI na partição"
	cmsgInstalacao_Automatica="Instalacao Automatica"
   cmsgInstalacao_Automatica_cancelada="Instalacao Automatica cancelada"
   cmsgErro_na_formatacao="Erro na formatação"
   cmsgErro_no_particionamento="Erro no particionamento"
   cmsgGerando_arquivo_configuracao_do_grub="Gerando arquivo de configuracao do grub"
	cmsgNeste_modo_a_instalacao_sera_automatizada="Neste modo a instalação será automatizada"
	cmsgDeseja_continuar_e_escolher_o_disco_destino="Deseja continuar e escolher o disco destino"
	cmsgDiscoIdem="Disco ORIGEM e DESTINO não podem serem o mesmo!"
}

en_US()
{
	lang="en_US"
	buttonback="Back"
	buttonpart="Disk Info"
  	cmsgErro="ERROR"
  	cmsgNaoEncontreiOComando="não encontrei o comando "
  	cmsgEsseScriptPrecisaDosComandosListadosAcima="Esse script precisa dos comandos listados acima"
   cmsgInstaleOuVerifique="Instale-os e/ou verifique se estão no seu \$PATH"
	cmsgOK="Ok"
	cmsg000="Exit"
	cmsg_select="Select"
	cmsg001=$ccabec
	cmsg002=$ctitle
	cmsg003=$welcome
	cmsg004="Choose an option:"
	cmsgBaixar_pacote_de_instalacao="Download installation package"
	cmsg006="Partition Disk"
	cmsg007="Choose partition"
	cmsg008="Quit the installer"
	cmsgquit="Quit the installer"
	cmsg009="Choose the SOURCE disk:"
	cmsgdest="Choose the DESTINATION disk:"
	cmsg010="Choose type:"
	cmsg011="Manual partitioning using cfdisk"
	cmsg012="Expert"
	cexpert="Expert"
	cnewbie="Newbie"
	cmsg013="Automatic partitioning (sfdisk)"
	cmsg014="Are you sure?"
	cmsg015="The minimum version does not include Xorg and DE. \nWould you like to download $cdistro minimal?"
	cmsg016='Would you like to download $cdistro full?'
	cmsgversion=$cmsg015
	cmsg017='Download canceled!'
	cancelinst="Installation canceled!"
	cancelbind="Chroot canceled!"
	cmsg018="Download full package (X)"
	cmsgTodos_os_dados_serao_perdidos="** NOTICE ** Will data will be lost!"
	cmsg021="Format partition"
	menuquit="Quit"
	menustep="Step by step"
	yeslabel="Yes"
	nolabel="No"
	cdlok1="*** DOWNLOAD ***"
	cdlok2="\n[OK] Download completed successfully."
	cdlok3="found."
	cdlok4="\n\nStart the installation now?"
	cshaok="\n[OK] Checksum successfully verified."
   plswait="Please wait, Downloading package..."
	cfinish="Install Complete!\nReboot to start with $cdistro Linux. \n\nBugs? $xemail"
	cgrubsuccess="GRUB successfully installed!"
	ccancelgrub="Installing grub canceled!"
	cmsgInstalar_GRUB="Install GRUB"
	cmsgAlterar_FSTAB="Change FSTAB"
	cinitbind="Start BIND"
	cconfuser="Configure user and password"
	cconfusernow="Configure user and password now"
	ccreatenewuser="Create a new user"
	#cGrubMsgInstall="Would you like to install grub? \
    #  				\n\n*Remembering that we do not yet have dual boot support. \
    #				\nIf use dualboot, use the grub from its other distribution with:\n# update-grub"
	cGrubMsgInstall="Would you like to install grub?"
	cchooseX="Choose your Desktop Environment"
	cxfce4="Classic and powerfull!"
	ci3wm="Desktop for avanced guys B)."
	cmsgmin="Minimum installation, not X"
   cmsgfull="Complete installation. *8.2G disk (Xfce4 or i3wm)"
	cwgeterro0="Sem problemas"
	cwgeterro1="Erro genérico"
	cwgeterro2="Erro de parse"
	cwgeterro3="Erro de I/IO no arquivo"
	cwgeterro4="Falha na rede"
	cwgeterro5="Falha na verificação do certificado SSL"
	cwgeterro6="Falha na autenticação (usuário ou senha)"
	cwgeterro7="Erro de protocolo"
	cwgeterro8="Servidor enviou uma respostar de erro"
	cerrotar0="Sucesso"
	cerrotar1="Árvore de diretório ruim, não conseguiu extrair um arquivo solicitado, \
   			   \narquivo de entrada igual ao arquivo de saída, falha ao abrir o arquivo de entrada, \
			   \nnão foi possível criar um  link, tabela link  malloc  falhouSucesso"
	cerrotar2="Erro de internacionalização que nunca deveria ocorrer, erro de checksum"
	cerrotar5="Erro de checksum"
	cerrotar9="(EBADF) - Erro lendo /etc/default/tar, fim de volume mal colocado"
	cerrotar12="(ENOMEM) – falha na alocação de memória para buffer"
	cerrotar22="(EINVAL) – invocação ruim (erros de sintaxe do arqumento),\
                \nparâmetros ruins para opções(ENOMEM) – falha na alocação de memória para buffer"
	cerrotar28="(ENOSPC) – arquivo muito grande para um volume"
	cerrotar78="(ENAMETOOLONG) - cwd name muito longo"
	cerrotar171="(ETOAST) – unidade de fitas on fire"
	ctools="Tools/Settings"
	cmsgtestarota="Please wait, testing route to the $cdistro server..."
	cmsgdelsha256="Please wait, deleting old SHA256SUM..."
	cmsgusermanager="$cdistro Linux user management"
	cmsgPacotes_disponiveis="Available packages"
   cmsggetshasum="Please wait, download sha256sum new..."
	cmsgdelpackageindex="Please wait, deleting old index..."
   cmsgdeltarball="Please wait, deleting old tarball..."
   cmsgtestsha256sum="Wait, testing sha256sum"
	cmsgadduser="Please wait, creating user..."
	cmsgaddhost="Please wait, setting hostname..."
   cmsgerrotar="Error in package unpacking"
	cmsgwaitgrub="Please wait, installing grub to disk"
	cmsgnoroute="Oops, no route to the $cdistro server! \nCheck your internet."
	cmsgerrodlsha1="Ops, error downloading of"
	cmsgerrodlsha2="Check your internet."
	cmsgcorrdlnew="Ops, corrupted package or SHA256. \nDownload the package again?"
	cmsg_corr_rep="Ops, corrupted package or SHA256. \nPlease retry the operation!"
	cmsg_erro_tar_continue="Error in decompressing the package. \nDo you want to continue?"
	cmsg_all_ready="All ready to begin the installation. Do you confirm?"
   cmsg_wget_package_index="Wait, downloading package index..."
	cmsg_nec_dismount="Need to dismount partition to repartition automatically."
	cwarning="** WARNING **"
	cmsg_alert_mount="Just to remember that the disk contains mounted partitions."
	cmsgA_particao_esta_montada="The partition is mounted"
	cmsg_dismount="Disassemble?"
	cmsg_all_mounted_part="The selected disk contains mounted partitions."
	cmsg_umount_partition="Please wait, dismantling the working partition."
	cmsg_create_dir="wait, creating working directory."
	cmsg_mount_partition="Please wait, setting up workpart."
	cmsg_try_mount_partition="Partition already mounted. Try?"
	cmsg_mount_failed="Partition mount failed. Repeat?"
	cmsg_enter_work_dir="Please wait, entering the work directory."
	cmsg_mkfs_ok="Formation completed successfully."
	cmsg_mkfs_error="Formatting error."
	cdisco="DISK"
	cmsg_disco_origem="SOURCE DISK"
	cmsg_disco_destino="DESTINATION DISK"
	cparticao="PARTITION"
	cmsg_extracting="Wait, Extracting files..."
	cmsg_part_disk="View disk partitions"
   cmsg_prepare_disk="Wait, preparing the disk:"
   cmsg_install_grub_disk="Installing grub on disk"
   cmsg_Detectada_particao_EFI="Detected EFI partition"
   cmsg_Deseja_instalar_o_GRUB_EFI="Do you want to install EFI grub"
   cmsg_Sim_EFI="Yes=EFI"
   cmsg_Nao_MBR="No=MBR"
   cmsg_Desmontando_particao="Unmounting partition"
   cmsg_Formatando_particao="Formatting partition"
   cmsg_Montando_particao="Mounting partition"
   cmsg_Instalando_GRUB_EFI_na_particao="Installing EFI grub on partition"
	cmsgInstalacao_Automatica="Automatic installation"
   cmsgInstalacao_Automatica_cancelada="Automatic installation canceled"
   cmsgErro_na_formatacao="Error in formatting"
   cmsgErro_no_particionamento="Partitioning error"
   cmsgGerando_arquivo_configuracao_do_grub="Generating Grub configuration file"
	cmsgNeste_modo_a_instalacao_sera_automatizada="In this mode an installation will be automated"
	cmsgDeseja_continuar_e_escolher_o_disco_destino="Do you want to continue and choose the destination disk"
	cmsgDiscoIdem="SOURCE and DESTINATION disk can be the same!"
}

scrend()
{
	exit $1
}

sh_checkroot()
{
	if [ "$(id -u)" != "0" ]; then
		printf "${red} error: You should run this script as root!\n"
		scrend 0
	fi
}

init()
{
	while true; do
		i18=$(${DIALOG}														\
			--stdout                                              \
			--backtitle	 	"$ccabec"				                  \
			--title 			"$welcome"			                    	\
			--ok-label		"$cmsgOK"	 									\
			--cancel-label	"$cmsg000"	 									\
			--menu			'\nChoose the language:'					\
	        	0 80 0                                 				\
				1 'Português'						 							\
	       	2 'English'							  							)

			exit_status=$?
			case $exit_status in
				$ESC)
					clear
					scrend 1
					;;
				$CANCEL)
               clear
					scrend 0
					;;
			esac
			case $i18 in
				1)
					pt_BR
					choosedisk
					;;
				2)
					en_US
					choosedisk
					;;
			esac
	done
}

sh_checkDependencies()
{
	local errorFound=0
	for command in "${DEPENDENCIES[@]}"; do
   if ! which "$command"  &> /dev/null ; then
   	printf "%s\n" "$(DOT)${red}$cmsgErro: $cmsgNaoEncontreiOComando ${yellow}'$command'${reset}"
     	errorFound=1
	fi
  	done

  	if [[ "$errorFound" != "0" ]]; then
   	echo
    	printf "%s\n" "$cmsgEsseScriptPrecisaDosComandosListadosAcima"
    	printf "%s\n" "$cmsgInstaleOuVerifique"
    	exit 1
  	fi
}

sh_version()
{
	printf "${orange}${0##*/} ${_VERSION_}\n"
}

#figlet
sh_logo()
{
   cat << 'EOF'
      _                      _ _     _
  ___| | ___  _ __   ___  __| (_)___| | __   Copyright (c) 2019-2022 Vilmar Catafesta <vcatafesta@gmail.com>
 / __| |/ _ \| '_ \ / _ \/ _` | / __| |/ /   Copyright (c) 2019-2022 Chili GNU/Linux Development Team
| (__| | (_) | | | |  __/ (_| | \__ \   <
 \___|_|\___/|_| |_|\___|\__,_|_|___/_|\_\   Este programa pode ser redistribuído livremente
                                             sob os termos da Licença Pública Geral GNU.
EOF
   sh_version
}

sh_display()
{
   if [ $(tput cols) -lt 80 ] || [ $(tput lines) -lt 24 ]; then
      ${DIALOG} --backtitle "$ccabec"          \
      --title "TERMINAL TOO SMALL" \
      --msgbox "\n\
Before you continue, re-size your terminal\nso it measures at least 80 x 24 characters.\n\
Otherwise you will not to able to use disk partition tools." 11 68
	fi
}

testelang()
{
	langmsg=(
				'lang=("pt BR" "en_US")'
				'cmsgerror=("ERRO" "ERROR")'
	)
	for elt in "${langmsg[@]}"; do eval $elt; done
	echo "lang      -> ${#lang[@]} ${lang[@]} ${lang[0]} ${lang[1]}"
	echo "cmsgerror -> ${#cmsgerror[@]} ${cmsgerror[@]} ${cmsgerror[0]} ${cmsgerror[1]}"
}

usage()
{
	printf "${cyan}Most used commands:\n"
	printf "${red}	-h  ${reset}- display this help and exit\n"
	printf "${red}	-v  ${reset}- display version\n"
	printf "${red}	-c  ${reset}- no color\n"
}

#testelang

sh_checkroot
sh_configure
en_US
sh_checkDependencies
sh_display
##############################################################################################################
#while getopts "vch" o; do
#    case "${o}" in
#    	v) sh_logo; exit 0;;
#	   n) unsetvarcolors;;
#	   h) usage; exit 0;;
#    esac
#done
#shift $((OPTIND-1))

#if [[ $1 = "-v" || $1 = "--version" || $1 = "-V" ]]; then
#	sh_logo
#	exit 0
#fi
##############################################################################################################
#TEMP=$(getopt -o vnh: --long version,nocolor,help:,debugfile:,minheap:,maxheap: -n 'clonedisk' -- "$@")
#if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi
if ! TEMP=$(getopt -o vnh --long version,nocolor,help -n ${0##*/} -- "$@")
then
	usage; exit 1
fi
eval set -- "$TEMP"
while true; do
	case "$1" in
		-v|--version) 	sh_logo; exit 0;;
		-n|--nocolor)	unsetvarcolors; break;;
		-h|--help) 		usage; exit 0;;
		--) shift; break;;
		*) break;;
	esac
done

aflag=no
bflag=no
cargument=none

# options may be followed by one colon to indicate they have a required argument
if ! options=$(getopt -o abc: -l along,blong,clong: -n 'clonedisk' -- "$@")
then
    # something went wrong, getopt will put out an error message for us
    exit 1
fi
set -- $options
while [ $# -gt 0 ]
do
	case $1 in
   -a|--along) aflag="yes" ;;
   -b|--blong) bflag="yes" ;;
   # for options with required arguments, an additional shift is required
   -c|--clong) cargument="$2" ; shift;;
   (--) shift; break;;
   (-*) echo "$0: error - unrecognized option $1" 1>&2; exit 1;;
   (*) break;;
   esac
   shift
done

init

:<<'LIXO'
Passagem padrão original de Lorem Ipsum, usada desde o século XVI.

"Lorem ipsum dolor sit amet, consectetur adipiscing elit, do eiusmod tempor incididunt ut labore et dolore magna aliqua.
Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure
dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum."
'LIXO'

# vim:set ts=3 sw=3 et:
