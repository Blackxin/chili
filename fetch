#!/usr/bin/env bash

# 	fetch - search, install, create, remove, upgrade packages compatible with:
# 	Chili GNU/Linux - https://github.com/vcatafesta/ChiliOS
#	Chili GNU/Linux - https://chililinux.com
#	Chili GNU/Linux - https://chilios.com.br
# 	MazonOS GNU/Linux - http://mazonos.com
#
# 	Created: 2019/04/05
# 	Altered: 2022/06/22
#
# 	Copyright (c) 2019-2022, Vilmar Catafesta <vcatafesta@gmail.com>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# 	fetch uses quite a few external programs during its execution. You
# 	need to have at least the following installed for makepkg to function:
#  	awk, bsdtar (libarchive), bzip2, coreutils, fakeroot, file, find (findutils),
#   	gettext, gpg, grep, gzip, sed, tput (ncurses), xz
# 	contains portion of software https://bananapkg.github.io/
#########################################################################
# debug
#declare -A cores=( [bla]=0 [red]=1 [gre]=2 [yel]=3 [blu]=4 [mag]=5 [cya]=6 [whi]=7 )
#fg=${cores[bla]}
#bg=${cores[red]}
#export PS4=$'+\t${0##*/}[$LINENO] '
#set -x
#set -Eeuo pipefail
#trap 'echo "${BASH_SOURCE}:${LINENO}:${FUNCNAME:-}"' ERR

# Import lib
LIBRARY=${LIBRARY:-'/usr/share/fetch'}
SYSCONFDIR=${SYSCONFDIR:-'/etc/fetch'}
source "${LIBRARY}"/core.sh
# debug
setvarcolors
export PS4=$'${red}${0##*/}${green}[$FUNCNAME]${pink}[$LINENO]${reset} '
#set -x
# end debug
#set -a 						# Enable allexport using single letter syntax
#set -o allexport 		# Enable using full option name syntax
#set +a 						# Disable allexport using single letter syntax
#set +o allexport 		# Enable using full option name syntax

configure()
{
	export LC_ALL=C
	export LANG=C
	readonly _VERSION_="3.22.20220622"
	readonly DEPENDENCIES=(which find tar zstd curl sed grep cat awk tput stat tee lynx)
	unset CDPATH
	unset GREP_OPTIONS

	[[ -e  "$SYSCONFDIR/fetch.conf" ]] || sh_touchconf
	source "$SYSCONFDIR/fetch.conf"

	# files
   FOLDERS_METAPACKAGES='folders_metapackages.csv'
   METAPACKAGES='metapackages.csv'
   PACKAGES_SPLIT='packages-split.csv'
   PACKAGES_INSTALLED_SPLIT='packages-installed-split.csv'
   PACKAGES_IN_CACHE='packages-in-cache.csv'

	# default
	export PKG_EXT SEP SITE GITSITE RAW APP
	export CACHEDIR CACHEDIR_ARCHIVES CACHEDIR_SEARCH
	export DESCME CACHEDIR_LIST CACHEDIR_DESC CACHEDIR_REMO
	export ALIEN_CACHE_DIR ALIEN_VARLIB
	export VARLIB_FETCH
	verbose=0
	SEP=','
	PKG_EXT="${PKG_EXT:='chi.zst'}"
	SITE="${PKG_SITE:=http://chililinux.com}"
	GITSITE="${GITSITE:=0}"
	RAW="${PKG_RAW:=https://raw.githubusercontent.com/vcatafesta/ChiliOS/master}"
	APP="fetch"	# APP="${0##*/}"
	CACHEDIR="${CACHEDIR:=/var/cache/$APP}"
	CACHEDIR_ARCHIVES="$CACHEDIR/archives"
	CACHEDIR_SEARCH="$CACHEDIR/search"
	CACHEDIR_LIST="$CACHEDIR/list"
	CACHEDIR_DESC="$CACHEDIR/desc"
	CACHEDIR_REMO="$CACHEDIR/remove"
	DESCME='info/desc'
	ALIEN_CACHE_DIR="${ALIEN_CACHE_DIR:=/var/cache/pacman/pkg}"
	ALIEN_VARLIB="/var/lib/pacman/local"
	VARLIB_FETCH="/var/lib/$APP"

	#temporary
	TMP_DIR_ROOT="$(mktemp -d -u)"
	TMP_DIR_BACKUP="$TMP_DIR_ROOT/$APP/$CACHEDIR_SEARCH"
	TMP_DIR_FOLDERS="$TMP_DIR_ROOT/$APP/$CACHEDIR/folders"

	# regex's
	DATE_RE='(\d{4}-\d{2}-\d{2}\s\d{2}:\d{2})'   #2022-03-16 14:22
	#RE_ALIEN='.+\.zst$|.+\.xz$' 						#VC
	#RE_ALIEN='.+\.[zst|xz]+$'  						#VC
	RE_ALIEN='.+\.(zst|xz)$'   						#Bagatini/Blau

	if [[ "$PKG_EXT" = "chi.zst" ]]; then
		#PKG_RE='^([a-z-]+)(-)([0-9\\.]+)(-)([0-9])(-)(.*)(.chi.zst)$'
		#PKG_RE='([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*)-(([0-9]+(\.[0-9]+)*)(-([0-9]+))?)-([^.]+).*'
		#PKG_RE='(.+)-(([^-]+)-([0-9]+))-([^.]+)\.chi\.zst' 				#SOEN
#		PKG_RE='(.+)-(([^-]+)-([0-9]+))-([^.]+)\.chi\.zst'    			#VC
		PKG_RE='(.+)-(([^-]+)-([0-9]+))-([^.]+)(\.chi\.zst)$'   			#VC
		PKG_RE_LYNX='(?!.*\/)(.*)-(([^-]+)-([0-9]+))-([^.]+)(\.chi\.zst)$'
		PKG_RE_FULL1='(?:")(.+)-(([^-]+)-([0-9]+))-([^.]+)\.chi\.zst(?="><a)'
		PKG_RE_FULL2='(?:e">)(.+)-(([^-]+)-([0-9]+))-([^.]+)(\.chi)(\.zst)(?=<\/a)'
		GREP_RE='.chi\.zst\"'
	else
		#PKG_RE='(.+)-(([^-]+)-([0-9]+))\.mz' 						#SOEN
		PKG_RE='(.+)-(([^-]+)-([0-9]))\.mz' 						#VC
		PKG_RE_LYNX='(?!.*\/)(.+)-(([^-]+)-([0-9]))\.mz$'		#VC
		GREP_RE='.mz\"'
	fi
}

sh_touchconf(){
	[[ -d "${SYSCONFDIR}" ]] || mkdir -p $SYSCONFDIR &> /dev/null
	cat > $SYSCONFDIR/fetch.conf << '_EOF_'
######################################################################
# fetch.conf
######################################################################
# extension of packages: chili=chi.zst, mazonos=mz
#PKG_EXT='mz'			# http://mazonos.com
PKG_EXT='chi.zst'		# https://chililinux.com | https://github.com/vcatafesta/ChiliOS

# packages hosted on GITHUB repository: yes='1', not='0'
GITSITE='0'

# distro hosting website/packages
#PKG_SITE='https://github.com/vcatafesta/ChiliOS/tree/master'		# for use set GITSITE=1
PKG_SITE='https://chililinux.com'					    					# for use set GITSITE=0
#PKG_SITE='https://chilios.com.br'											# for use set GITSITE=0
#PKG_SITE='https://chililinux.org'					     					# for use set GITSITE=0
#PKG_SITE='https://chililinux.online'				  	   				# for use set GITSITE=0
#PKG_SITE='https://sybernet.com.br'				  	   					# for use set GITSITE=0
#PKG_SITE='http://localhost'													# for use set GITSITE=0
#PKG_SITE='http://mazonos.com'												# for use set GITSITE=0

#not needed change
PKG_RAW='https://raw.githubusercontent.com/vcatafesta/ChiliOS/master'

# configuration for generation new packages
MAINTAINER='Vilmar Catafesta <vcatafesta@gmail.com>'
GPG_SIGN='0'
REWRITE_SIGN='1'
CREATE_SHA256='0'
DESC_BUILD='1'
URL='https://www.linuxfromscratch.org/lfs/view/stable/'
LICENSE='GPL2'
LFS_VERSION='11.1'
LFS_INIT='SYSTEMD'
ARCH='x86_64'
DISTRO='chili'
GITDIR='/github/ChiliOS'
PKGCORE="$GITDIR/packages/core"
CACHEDIR='/var/cache/fetch'
ALIEN_CACHE_DIR='/var/cache/pacman/pkg'
IGNOREPKG=('glibc' 'file')

#end
_EOF_
}

clinesplit()
{
   printf "%s%s%s%s%s%s%s%s"                            \
                  "${aPKGSPLIT[$PKG_BASE]}$SEP"         \
                  "${aPKGSPLIT[$PKG_VERSION]}$SEP"      \
                  "${aPKGSPLIT[$PKG_BUILD]}$SEP"        \
                  "${aPKGSPLIT[$PKG_FULLNAME]}$SEP"     \
                  "${aPKGSPLIT[$PKG_PKG_FOLDER_DIR]}/${aPKGSPLIT[$PKG_FULLNAME]}$SEP" \
                  "${aPKGSPLIT[$PKG_BASE_VERSION]}$SEP" \
                  "${aPKGSPLIT[$PKG_SIZE]}$SEP"         \
                  "${aPKGSPLIT[$PKG_FOLDER_DIR]}"
}

clineascan()
{
   printf "${aPKGARRAY[0]}$SEP${aPKGARRAY[1]}$SEP${aPKGARRAY[2]}$SEP${aPKGARRAY[3]}$SEP${aPKGARRAY[4]}$SEP${aPKGARRAY[5]}$SEP${aPKGARRAY[6]}"
}

sh_arraypkgfull()
{
	OLDIFS=$IFS
	local file_list_packages="$1"
   [[ $# -eq 0 ]] && file_list_packages="$CACHEDIR_SEARCH/$PACKAGES_SPLIT"

	public_len_count_main=0
	public_len_count_pkg=0

   export public_pkg_base
   export public_pkg_version
   export public_pkg_build
   export public_pkg_fullname
   export public_pkg_dirfullname
   export public_pkg_base_version
   export public_pkg_size
   export public_pkg_site
   export public_pkg_main

	if (( verbose >= 2 )); then
		log_msg "Checking packages"
	fi

	while IFS=, read -r fld1 fld2 fld3 fld4 fld5 fld6 fld7 fld8; do
	   public_pkg_base+=("${fld1}")
	   public_pkg_version+=("${fld2}")
	   public_pkg_build+=("${fld3}")
	   public_pkg_fullname+=("${fld4}")
	   public_pkg_dirfullname+=("${fld5}")
	   public_pkg_base_version+=("${fld6}")
	   public_pkg_size+=("${fld7}")
	   public_pkg_site+=("${fld8}")
	done < $file_list_packages

	public_pkg_main=(
		public_pkg_base[@]
		public_pkg_version[@]
		public_pkg_build[@]
		public_pkg_fullname[@]
		public_pkg_dirfullname[@]
		public_pkg_base_version[@]
		public_pkg_size[@]
		public_pkg_site[@]
	)
	public_len_count_main=${#public_pkg_main[*]}
	public_len_count_pkg=${#public_pkg_base[*]}
	IFS=$OLDIFS
}

sh_arraypkgfullAWK()
{
	local file_list_packages=$1
   [[ $# -eq 0 ]] && file_list_packages="$CACHEDIR_SEARCH/$PACKAGES_SPLIT"

	public_len_count_main=0
	public_len_count_pkg=0

	if (( verbose >= 2 )); then
		log_msg "Checking packages"
	fi

	public_pkg_base=($(awk -F$SEP '{ print $1 }' $file_list_packages))
	public_pkg_version=($(awk -F$SEP '{ print $2 }' $file_list_packages))
	public_pkg_build=($(awk -F$SEP '{ print $3 }' $file_list_packages))
	public_pkg_fullname=($(awk -F$SEP '{ print $4 }' $file_list_packages))
	public_pkg_dirfullname=($(awk -F$SEP '{ print $5 }' $file_list_packages))
	public_pkg_base_version=($(awk -F$SEP '{ print $6 }' $file_list_packages))
	public_pkg_size=($(awk -F$SEP '{ print $7 }' $file_list_packages))
	public_pkg_site=($(awk -F$SEP '{ print $8 }' $file_list_packages))

	public_pkg_main=(
		public_pkg_base[@]
		public_pkg_version[@]
		public_pkg_build[@]
		public_pkg_fullname[@]
		public_pkg_dirfullname[@]
		public_pkg_base_version[@]
		public_pkg_size[@]
		public_pkg_site[@]
	)
	public_len_count_main=${#public_pkg_main[*]}
	public_len_count_pkg=${#public_pkg_base[*]}

#	for ((i=0; i<=$public_len_count_pkg; i++))
#	do
#		for ((x=0; x<=$public_len_count_main; x++))
#		do
#	w
#		printf ":${!public_pkg_main[x]:$i:1}"
#		done
#		echo
#	done
	return $public_len_count_pkg
}

sh_ascanpkg()
{
	local pkgsearch=$1
	local pkgfile=$2
	local indice=0
	aPKGARRAY=()

	case $pkgfile in
		0)	indice=$( printf "%s\n" "${public_pkg_base[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1 );;
		1)	indice=$( printf "%s\n" "${public_pkg_version[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1 );;
		2)	indice=$( printf "%s\n" "${public_pkg_build[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1 );;
		3)	indice=$( printf "%s\n" "${public_pkg_fullname[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1 );;
		4)	indice=$( printf "%s\n" "${public_pkg_dirfullname[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1 );;
		5)	indice=$( printf "%s\n" "${public_pkg_base_version[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1 );;
		6)	indice=$( printf "%s\n" "${public_pkg_size[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1 );;
		7)	indice=$( printf "%s\n" "${public_pkg_site[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1 );;
	esac

	if [[ -z $indice ]]; then
		return $false
	fi

	(( indice-- ))
	aPKGARRAY=(	"${public_pkg_base[$indice]}"
					"${public_pkg_version[$indice]}"
					"${public_pkg_build[$indice]}"
					"${public_pkg_fullname[$indice]}"
					"${public_pkg_dirfullname[$indice]}"
					"${public_pkg_base_version[$indice]}"
					"${public_pkg_size[$indice]}"
					"${public_pkg_site[$indice]}"
					)
	return $true
}

sh_cabec() #$1 nfiles
{
	printf "(${pink}%04d)${green} sts package%47sversion%8s%11ssize fullbasename\n" $1
}

sh_write()
{
	local pkgsearch=$1
	local pkgfile=$2
	local pkgCheckNumber=$3
	local strstatus='         '
   local status=$4

   [[ -z $status ]] && status=' A '
	sh_ascanpkg "$pkgsearch" "$pkgfile"
	[[ $status = ' I ' ]] && strstatus='installed'
	printf "${green}%s(%04d) ${cyan}$status ${orange}%-43s$cyan $strstatus ${reset}%-15s%15s %s\n"		\
			 ""		 																												\
			 "$pkgCheckNumber" 																									\
			 "${aPKGARRAY[0]}"																									\
			 "${aPKGARRAY[1]}"																									\
			 "$(size_to_human ${aPKGARRAY[6]})"																				\
			 "${aPKGARRAY[3]}"
}

sh_footer()
{
	local pkgCheckNumber=$1
	log_msg "${green}($pkgCheckNumber)${reset} package(s) found."
}

# -La
sh_list()
{
	local param=$@
	local nfiles
	local arr
	local s
	local x
	local status=' A '
	local	SEARCH_CUT='-f1'
	local pkg

	LLIST=$true

	if (( LLIST )); then
		if (( verbose >= 2 )); then
			log_msg "Reading package lists in the repository"
		fi
	fi

	for s in ${param[@]}; do
		cListSearch+="$s "
	done

	if (( LALL )) || [[ "$cListSearch" == "" ]]; then
		if (( LALL )); then
			pkg=$(cat $CACHEDIR_SEARCH/$PACKAGES_SPLIT | cut -d$SEP -f1)
		else
			log_failure_msg2 "${red}error${reset}: nenhum alvo definido (use -h para obter ajuda)"
			exit 1
		fi
	else
		for x in ${cListSearch}; do
			if (( LEXACT )); then
				pkg+="$(grep ^$x$SEP $CACHEDIR_SEARCH/$PACKAGES_SPLIT | cut -d$SEP -f1) "
			else
				pkg+="$(grep $x $CACHEDIR_SEARCH/$PACKAGES_SPLIT | cut -d$SEP -f1) "
			fi
		done
	fi

	arr=(${pkg[*]})
	nfiles=${#arr[*]}

	if (( LLIST )); then
		pkgCheckNumber=0
		if (( nfiles )); then
			sh_arraypkgfull
			if (( verbose )); then
				sh_cabec $nfiles
			fi

			for i in $pkg; do
				((pkgCheckNumber++))
				if (( verbose )); then
					if grep -q ^$i$SEP $CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT; then
						status=' I '
					else
						status=' A '
					fi
					[[ LLIST = $true ]] && sh_write $i '0' $pkgCheckNumber "$status"
				fi
			done
		fi
	fi
	sh_cdroot
}

# -Li
sh_listinstalled()
{
	local param=$@
	local pkgNumber=0
	local s
	local cListSearch
	local ntotalpkg=0
	local arr
	local arrd

	if (( verbose >= 2 )); then
		log_msg "Listing installed packages"
	fi
	LLIST=$true
	LALL=$false
	LDEPS=$false
	SPLITPOS='0'

	if [[ -z "${param}" ]]; then
		LALL=$true
	fi

	sh_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" ${param}
}

# -Li
sh_listpkgdisp()
{
	local file_list_package=$1
	shift
	local file_list_installed=$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT
	local param=$@
	local s
	local SEARCH_CUT='-f5'
	local ncontapkg=0
	local arr
	public_ListSearch=
	public_pkg_not_found=()

	[[ -e ${file_list_installed} ]] || printf '' > "${file_list_installed}"
   sh_arraypkgfull $file_list_package
	public_ntotal_pkg_installed=$(grep ^ ${file_list_installed} | wc -l)
	public_ntotal_pkg_listed=$public_ntotal_pkg_installed
	public_pkg=
	public_pkg_deps=
	public_size=()
	public_ListSearch=$param

	if [[ "$SPLITPOS" == "" ]]; then
		SPLITPOS='4'
		SEARCH_CUT='-f5'
		AWK_CUT='$5'
 	elif [[ "$SPLITPOS" == "0" ]]; then
		SEARCH_CUT='-f1'
		AWK_CUT='$1'
 	elif [[ "$SPLITPOS" == "4" ]]; then
		SEARCH_CUT='-f5'
		AWK_CUT='$5'
	fi

	if (( LALL )) || [[ "$public_ListSearch" == "" ]]; then
		if (( LALL )); then
#			public_pkg=$(grep ^ $file_list_package | cut -d$SEP $SEARCH_CUT)
			public_pkg=$(awk -F$SEP '{print '$AWK_CUT'}' $file_list_package)
		else
			log_failure_msg2 "${red}error${reset}: nenhum alvo definido (use -h para obter ajuda)"
			exit 1
		fi
	else
		for x in ${public_ListSearch}; do
			if (( LEXACT )); then
				pkg_grep=$(grep ^$x$SEP $file_list_package | cut -d$SEP $SEARCH_CUT)
			else
#				public_pkg="$public_pkg $(grep $x $file_list_package | cut -d$SEP -f5)"
				pkg_grep=$(grep $x $file_list_package | cut -d$SEP $SEARCH_CUT)
#				pkg_grep=$(awk -F $SEP '$AWK_CUT - /$x/ { print '$AWK_CUT'}' $file_list_package)
			fi
			if [[ -n "$pkg_grep" ]]; then
				public_pkg+="$pkg_grep "
			else
				if ! (( LSKIPERROR )); then
					if (( LREMOVE )); then
						log_failure_msg "${red}error: ${orange}$x ${reset}target was ${red}NOT INSTALLED. ${reset}Use the ${yellow}${0##*/} -Sr ${reset}option to rebuild installed packages."
					else
						log_failure_msg "${red}error: ${orange}$x ${reset}target was ${red}NOT found. ${reset}Use the ${yellow}--skiperror ${reset}option to force install. "
					fi
					exit 1
				else
					log_failure_msg "${red}error${reset}: ${orange}${x} ${reset}target was ${red}NOT ${reset}found. ${yellow}Skipping"
				fi
				public_pkg_not_found+=("$x")
			fi
			if ! (( LSEARCHONLY )); then
				pkginstalled=$(grep ^$x$SEP $CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT | cut -d$SEP $SEARCH_CUT)
				sh_splitpkg ${pkginstalled}
				if [[ -n "$pkginstalled" && "$pkg_grep" = "$pkginstalled" ]]; then
					log_failure_msg "${yellow}attention${reset}: ${orange}${aPKGSPLIT[$PKG_BASE_VERSION]} ${reset}está atualizado -- reinstalando."
	  			fi
  			fi
		done
	fi

	nfilesfound=$(lenarraystr "$public_pkg")

	if (( $nfilesfound )); then # package's found?
		if ! (( LREMOVE )); then
			if (( LDEPS )); then
				sh_getdeps $LDEPS
			fi
		fi

		ncontapkg=$(( $nfilesfound + $(lenarraystr "$public_pkg_deps") ))
		public_ntotal_pkg_listed=$ncontapkg

		if (( verbose )); then
			sh_cabec $ncontapkg
			pkgNumber=0
			for i in ${public_pkg[*]}
			do
				sh_write $i $SPLITPOS $((++pkgNumber))
  			done
			for i in ${public_pkg_deps[*]}
			do
				sh_write $i $SPLITPOS $((++pkgNumber)) "dep"
  			done
		fi
	fi
	sh_cdroot
	return $public_ntotal_pkg_listed
}

sh_checknet()
{
	# have internet?
	log_info_msg "${cyan}Testing internet from ${SITE}"
	curl --insecure $SITE >/dev/null 2>&1 ||
	{
		evaluate_retval
		log_failure_msg2 "No route to server ($SITE) - ABORTED."
		return 1
	}
	evaluate_retval
	return $?
}

sh_selfupdate()
{
	local param=$@

	if ! (( LAUTO )) || ! (( LFORCE)); then
		echo
		conf "Update ${0##*/} from internet?"
		LAUTO=$?
	fi

	if (( LAUTO )) || (( LFORCE )); then
		local link="$PKG_RAW/updater/src/fetch"
		local tmp_dir_full="/tmp/${APP}"
		local tmp_dir="/tmp/${APP}/src"

		#internet?
		sh_checknet; [[ $? = $false ]] || { return 1;}
		log_msg "Ok, let's do it..."
		#Ok, Puxe o arquivo do repositorio agora!
		[[ -d "${tmp_dir_full}" ]] && rm -r "${tmp_dir_full}"
		[[ -d "${tmp_dir}" ]] || mkdir -p "${tmp_dir}"
		pushd "${tmp_dir}" &>/dev/null
		log_info_msg "${cyan}Clonando $link"
		curl --insecure --silent --remote-name "${link}"
		evaluate_retval

		log_info_msg "${cyan}Permission and Copy archives"
		chmod +x ${tmp_dir}/fetch
		evaluate_retval

		log_info_msg "${cyan}Copying file ${yellow}fetch ${red}to ${yellow}${0}"
		cp -f ${tmp_dir}/fetch ${0}
		evaluate_retval

		log_info_msg "${cyan}Removing temporary files"
		[[ -d "${tmp_dir_full}" ]] && rm -r "${tmp_dir_full}"
		evaluate_retval
		log_info_msg "${violet}${0##*/} updated successfully, enjoy!"
		evaluate_retval
		exit 0
	fi
	return 1
	sh_cdroot
}

sh_clean()
{
	local lRetval=$false
	local param=$@
	local	nfiles=$(find $CACHEDIR_ARCHIVES -type f -iname "*.${PKG_EXT}" -type f  | wc -l)

	if ! (( $nfiles )); then
		printf '' >| "$CACHEDIR_SEARCH/$PACKAGES_IN_CACHE"
		log_msg "${yellow}($nfiles) ${cyan}find packages in cache"
		return $lRetval
	fi

	if ! (( LAUTO )); then
		printf "Pacotes a serem mantidos:\n"
      printf "      Todos os pacotes instalados localmente\n"
		printf "\n"
		printf "Cache directory: $CACHEDIR_ARCHIVES/\n"
		conf "${blue}:: ${reset}Do you want to remove all packages from the cache?"
		LAUTO=$?
	fi

	if (( LAUTO )); then
		log_msg "${pink}Deleting downloaded package files"
		[[ -d $CACHEDIR_ARCHIVES ]] && rm -f $CACHEDIR_ARCHIVES/*.${PKG_EXT}* || mkdir -p $CACHEDIR_ARCHIVES
		printf '' >| "$CACHEDIR_SEARCH/$PACKAGES_IN_CACHE"
		log_success_msg2 "${yellow}($nfiles) ${cyan}packages deleted"
		lRetval=$true
	fi
	sh_cdroot
	return $lRetval
}

sh_checkdir()
{
	if (( verbose >= 2 )); then
		log_msg "Checking job directories"
		log_info_msg "$CACHEDIR_ARCHIVES" ; [[ -d $CACHEDIR_ARCHIVES  ]] && evaluate_retval || { mkdir -p $CACHEDIR_ARCHIVES  >/dev/null 2>&1; evaluate_retval; }
		log_info_msg "$CACHEDIR_SEARCH"   ; [[ -d $CACHEDIR_SEARCH    ]] && evaluate_retval || { mkdir -p $CACHEDIR_SEARCH    >/dev/null 2>&1; evaluate_retval; }
		log_info_msg "$CACHEDIR_LIST"     ; [[ -d $CACHEDIR_LIST      ]] && evaluate_retval || { mkdir -p $CACHEDIR_LIST      >/dev/null 2>&1; evaluate_retval; }
		log_info_msg "$CACHEDIR_DESC"     ; [[ -d $CACHEDIR_DESC      ]] && evaluate_retval || { mkdir -p $CACHEDIR_DESC      >/dev/null 2>&1; evaluate_retval; }
		log_info_msg "$CACHEDIR_REMO"     ; [[ -d $CACHEDIR_REMO      ]] && evaluate_retval || { mkdir -p $CACHEDIR_REMO      >/dev/null 2>&1; evaluate_retval; }
		log_info_msg "$VARLIB_FETCH"      ; [[ -d $VARLIB_FETCH       ]] && evaluate_retval || { mkdir -p $VARLIB_FETCH       >/dev/null 2>&1; evaluate_retval; }
	else
		[[ -d $CACHEDIR_ARCHIVES  ]] || mkdir -p $CACHEDIR_ARCHIVES  >/dev/null 2>&1
		[[ -d $CACHEDIR_SEARCH    ]] || mkdir -p $CACHEDIR_SEARCH    >/dev/null 2>&1
		[[ -d $CACHEDIR_LIST      ]] || mkdir -p $CACHEDIR_LIST      >/dev/null 2>&1
		[[ -d $CACHEDIR_DESC      ]] || mkdir -p $CACHEDIR_DESC      >/dev/null 2>&1
		[[ -d $CACHEDIR_REMO      ]] || mkdir -p $CACHEDIR_REMO      >/dev/null 2>&1
		[[ -d $VARLIB_FETCH       ]] || mkdir -p $VARLIB_FETCH       >/dev/null 2>&1
	fi
	[[ -e $CACHEDIR_SEARCH/$PACKAGES_SPLIT           ]] || >> $CACHEDIR_SEARCH/$PACKAGES_SPLIT
	[[ -e $CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT ]] || >> $CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT

	return $?
}

# -Sy
sh_updaterepo()
{
	if (( LSELF )); then
		sh_selfupdate "$@"
		return $?
	fi
	local dw=("$FOLDERS_METAPACKAGES"
		 		 "$METAPACKAGES"
		 		 "$PACKAGES_SPLIT"
		 		)
	#internet?
	sh_checknet; [[ $? = $false ]] || { return 1;}

	local response=$(curl --compressed -s -w "%{http_code}\n" -o /dev/null -k --url "${SITE}/repo/")
	if [[ $response -eq 404 ]]; then
		log_failure_msg "${red}error${reset}: $response Not Found ${orange}==> $SITE/repo/"
		exit 1
	fi

	pushd $CACHEDIR_SEARCH/ &>/dev/null
	sh_backup

	log_msg "${pink}Cleaning up ${CACHEDIR_SEARCH}/${reset}"
	for i in "${dw[@]}"; do
		rm -f $CACHEDIR_SEARCH/${i}
	done

	log_msg "${pink}Updating file packages from ${SITE}/repo/${reset}"
	curl --silent --insecure -O ${SITE}/repo/${dw[0]} -O ${SITE}/repo/${dw[1]} -O ${SITE}/repo/${dw[2]}
	sh_cleaning
	unset FOLDER_TEMP

	local nfilesInReposit=$(wc -l < $CACHEDIR_SEARCH/$PACKAGES_SPLIT)
	local nfilesInstalled=$(wc -l < $CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT)
	log_msg "${cyan}All list packages updated!${reset}"
	log_msg "${blue}($(strzero $nfilesInReposit 5)) packages in the repository${reset}"
	log_msg "${green}($(strzero $nfilesInstalled 5)) installed packages${reset}"
	echo
	log_msg "${reset}Use: # ${0##*/} --help for helping${reset}"
	popd &>/dev/null
}

sh_update()
{
	local Folders
	local FoldersInRepo
	local PackagesInFolders
	local MetaPkgInFolders
	local MetaInFolder
	local nFiles=0
	local cstrvalue
	local dw=($CACHEDIR_SEARCH/$PACKAGES_SPLIT
             $CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES
             $CACHEDIR_SEARCH/$METAPACKAGES
            )

	if (( LSELF )); then
		sh_selfupdate "$@"
		return $?
	fi

	#internet?
	sh_checknet; [[ $? = $false ]] || { return 1;}

	local response=$(curl --compressed -s -w "%{http_code}\n" -o /dev/null -k --url "${SITE}/packages/")
	if [[ $response -eq 404 ]]; then
		log_failure_msg "${red}error${reset}: $response Not Found ${orange}==> $SITE/packages/"
		exit 1
	fi

	pushd $CACHEDIR_SEARCH/ &>/dev/null
	sh_backup

	log_msg "${pink}Cleaning up ${CACHEDIR_SEARCH}/${reset}"
   for i in "${dw[@]}"; do
      >| $i
   done

	log_msg "${pink}Updating folders from ${SITE}${reset}"
	FoldersInRepo=$(lynx -listonly -nonumbers -dump -justify "${SITE}/packages/" | grep -P -o '.*packages\/\K.*?(?=\/)')

	log_msg "${pink}Synchronizing package databases from ${SITE}${reset}"
	regex='^.*>(.+)-(([^-]+)-([0-9]+))-([^.]+)(.chi.zst)<.a>.*([0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}-[A-z]{3}-[0-9]{4})[ ]([0-9]{2}:[0-9]{2}).*[ ]([0-9]+k?)(.*)'
	for Folders in ${FoldersInRepo}; do
		FOLDER_TEMP="$TMP_DIR_FOLDERS/$Folders"
		response=$(curl --compressed --insecure -s -w "%{http_code}\n" -k --url "${SITE}/packages/${Folders}/" --output $FOLDER_TEMP)
#		wget https://chiliLinux.com/packages/a/ -qO - | sed -nE "s;$regex;\1 - \2 - \3;p"

		if [[ $Folders != "meta" ]]; then
#			PackagesInFolders=$(lynx -listonly -nonumbers -dump "$SITE/packages/$Folders/" |	grep File | awk '{print $2}')
#			PackagesInFolders=$(lynx -listonly -nonumbers -dump "$SITE/packages/$Folders/" | grep -Po "$PKG_RE_LYNX")
#			PackagesInFolders=($(wget "$SITE/packages/$Folders/" -qO - | grep -Po "$regex"))
#			PackagesInFolders=($(curl --compressed --insecure --silent --url "$SITE/packages/$Folders/" | grep -Po "$regex"))
#ok		PackagesInFolders=($(curl --compressed --insecure --silent --url "$SITE/packages/$Folders/" | sed -nE "s;$regex;\1-\2-\5\6;p"))
			PackagesInFolders=($(sed -nE "s;$regex;\1-\2-\5\6;p" $FOLDER_TEMP))
		else
			MetaPkgInFolders=$(lynx -listonly -nonumbers -dump "$SITE/packages/$Folders/" | grep -Po '.*\/\K.*')
		fi
#		SizePkgInFolders=$(lynx -nonumbers -dump "$SITE/packages/$Folders/" | grep File | awk '{print $5}')
#		SizePkgInFolders=($(wget "$SITE/packages/$Folders/" -qO - | grep -Po "$regex" | awk '{print $5*1024}'))
#		SizePkgInFolders=($(curl --compressed --insecure --silent --url "$SITE/packages/$Folders/" | grep -Po "$regex" | awk '{print $5*1024}'))
#		SizePkgInFolders=($(wget "$SITE/packages/$Folders/" -qO - | sed -nE "s;$regex;\3;p"))
#ok	SizePkgInFolders=($(curl --compressed --insecure --silent --url "$SITE/packages/$Folders/" | sed -nE "s;$regex;\9;p"))
		SizePkgInFolders=($(sed -nE "s;$regex;\9;p" $FOLDER_TEMP))
		nFiles=$(lenarray "$PackagesInFolders")

		local count=0
		if [[ $Folders != "meta" ]]; then
			for pkgInFolder in ${PackagesInFolders[@]}; do
				sh_splitpkg ${pkgInFolder}
				pkg_size=$(kbytestobytes ${SizePkgInFolders[$count]})
				echo "${aPKGSPLIT[$PKG_BASE]}$SEP${aPKGSPLIT[$PKG_VERSION]}$SEP${aPKGSPLIT[$PKG_BUILD]}$SEP${aPKGSPLIT[$PKG_FULLNAME]}$SEP${Folders}/${pkgInFolder}$SEP${aPKGSPLIT[$PKG_BASE_VERSION]}$SEP${pkg_size}" >> $CACHEDIR_SEARCH/$PACKAGES_SPLIT
				((count++))
			done
		else
			for MetaInFolder in ${MetaPkgInFolders[@]}; do
				echo "${Folders}/${MetaInFolder}" >> $FOLDERS_METAPACKAGES
				echo "${MetaInFolder}"            >> $METAPACKAGES
				((count++))
			done
		fi
		cstrvalue=$(strzero $count 5)
		log_success_msg2 "  Updating... (${blue}${cstrvalue}${reset}) packages in ${Folders}"
	done
#	{ kill $SPINNERPID; wait $SPINNERPID 2>/dev/null; echo ;}

	#sh_recreatefilepackagesinstalled
	sh_FilesInCache
	sh_cleaning
	unset FOLDER_TEMP

	local nfilesInReposit=$(wc -l < $CACHEDIR_SEARCH/$PACKAGES_SPLIT)
	local nfilesInstalled=$(wc -l < $CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT)
	local nfilesInCache=$(wc -l < $CACHEDIR_SEARCH/$PACKAGES_IN_CACHE)
	log_msg "${cyan}All list packages updated!${reset}"
	log_msg "${blue}($(strzero $nfilesInReposit 5)) packages in the repository${reset}"
	log_msg "${green}($(strzero $nfilesInstalled 5)) installed packages${reset}"
	log_msg "${green}($(strzero $nfilesInCache 5)) packages in cache $CACHEDIR_ARCHIVES${reset}"
	echo
	log_msg "${reset}Use: # ${0##*/} --help for helping${reset}"
	popd &>/dev/null
}

sh_updateOLD()
{
	if (( LSELF )); then
		sh_selfupdate "$@"
		return $?
	fi

	#internet?
	sh_checknet; [[ $? = $false ]] || { return 1;}

	local response=$(curl --compressed -s -w "%{http_code}\n" -o /dev/null -k --url "${SITE}/packages/")
	if [[ $response -eq 404 ]]; then
		log_failure_msg "${red}error${reset}: $response Not Found ${orange}==> $SITE/packages/"
		exit 1
	fi

	pushd $CACHEDIR_SEARCH/ &>/dev/null
	sh_backup

	log_msg "${pink}Cleaning up ${CACHEDIR_SEARCH}/${reset}"
	printf '' >| $CACHEDIR_SEARCH/$PACKAGES_SPLIT
	printf '' >| $CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES
	printf '' >| $CACHEDIR_SEARCH/$METAPACKAGES
	local HTTP_SERVER="$(string_alltrim $(curl --compressed -s -k --insecure --head -w '%{http_code}\n' --url "${SITE}" | grep '^[Ss]erver' | awk '{print $2}') | cut -d/ -f1)"

	#debug "${HTTP_SERVER}"
	#debug "$(string_len "${HTTP_SERVER}")"
	log_msg "${pink}Updating folders from ${SITE}${reset}"
	case ${HTTP_SERVER} in
		Apache|nginx)
			FoldersInRepo=$(curl --compressed --insecure --silent --url "${SITE}/packages/"|grep -E -o '>[[:alnum:]]*/'|sed 's/>//g;s/\///g' | tee ${CACHEDIR_SEARCH}/$FOLDERS)
			;;
		LiteSpeed|cloudflare)
			FoldersInRepo=$(curl --compressed --insecure --silent --url "${SITE}/packages/"|grep -E -o 'packages\/[a-z]+'|sed 's/packages\///g' | tee ${CACHEDIR_SEARCH}/$FOLDERS)
			;;
		GitHub.com)
			FoldersInRepo=$(curl --compressed --insecure --silent --url "${SITE}/packages/"|grep /packages/ |sed 's/<[^>]*>//g;s/ //g' | tee ${CACHEDIR_SEARCH}/$FOLDERS)
			;;
	esac

	log_msg "${pink}Synchronizing package databases from ${SITE}${reset}"
	#spinner & SPINNERPID=$!
	local Folders

#	lynx --nonumbers -dump -justify http://localhost/packages/a/ | grep -Po '(?!.*\/)(.*)-(([^-]+)-([0-9]+))-([^.]+)(\.chi\.zst)'

	for Folders in ${FoldersInRepo}; do
		FOLDER_TEMP="$TMP_DIR_FOLDERS/$Folders"
		response=$(curl --compressed --insecure -s -w "%{http_code}\n" -k --url "${SITE}/packages/${Folders}/" --output $FOLDER_TEMP)
		case ${HTTP_SERVER} in
			Apache|nginx)
				if [[ $Folders != "meta" ]]; then
				   PackagesInFolders=($(grep -E -o '>'$PKG_RE'<' $FOLDER_TEMP | sed 's/>//g; s/<//g'))
				else
					MetaPkgInFolders=($(grep -E '.meta\"' $FOLDER_TEMP | cut -d'"' -f2 ))
				fi
				SizePkgInFolders=($(grep -E $GREP_RE $FOLDER_TEMP | awk '{print $5}' ))
				;;
			LiteSpeed|GitHub.com|cloudflare)
				if [[ $Folders != "meta" ]]; then
#					PackagesInFolders=$(curl --compressed --insecure --silent --url "${SITE}/packages/${Folders}/"|sed 's/^.*href="//' | sed 's/".*$//' | sed 's/\// /g' | grep ".${PKG_EXT}$"| awk '{print $NF}')
					PackagesInFolders=$(cat $FOLDER_TEMP | sed 's/^.*href="//' | sed 's/".*$//' | sed 's/\// /g' | grep -E ".${PKG_EXT}$"| awk '{print $NF}')
				else
#					MetaPkgInFolders=$(curl --compressed --insecure --silent --url "${SITE}/packages/${Folders}/" |sed 's/^.*href="//' | sed 's/".*$//' | sed 's/\// /g' | grep ".meta$" | awk '{print $NF}')
					MetaPkgInFolders=$(cat $FOLDER_TEMP | sed 's/^.*href="//' | sed 's/".*$//' | sed 's/\// /g' | grep -E ".meta$" | awk '{print $NF}')
				fi
				SizePkgInFolders=($(grep -E $GREP_RE $FOLDER_TEMP | awk '{print $9}' | cut -d'"' -f2))
				;;
		esac

		local count=0
		if [[ $Folders != "meta" ]]; then
			for pkgInFolder in ${PackagesInFolders[@]}; do
				sh_splitpkg ${pkgInFolder}
				pkg_size=${SizePkgInFolders[$count]}
				echo "${aPKGSPLIT[$PKG_BASE]}$SEP${aPKGSPLIT[$PKG_VERSION]}$SEP${aPKGSPLIT[$PKG_BUILD]}$SEP${aPKGSPLIT[$PKG_FULLNAME]}$SEP${Folders}/${pkgInFolder}$SEP${aPKGSPLIT[$PKG_BASE_VERSION]}$SEP${pkg_size}" >> $CACHEDIR_SEARCH/$PACKAGES_SPLIT
				((count++))
			done
		else
			for MetaInFolder in ${MetaPkgInFolders[@]}; do
				echo "${Folders}/${MetaInFolder}" >> $FOLDERS_METAPACKAGES
				echo "${MetaInFolder}"            >> $METAPACKAGES
				((count++))
			done
		fi
		cstrvalue=$(strzero ${count} 5)
		log_success_msg2 "  Updating... (${blue}${cstrvalue}${reset}) packages in ${Folders}"
	done
#	{ kill $SPINNERPID; wait $SPINNERPID 2>/dev/null; echo ;}

	#sh_recreatefilepackagesinstalled
	sh_FilesInCache
	sh_cleaning
	unset FOLDER_TEMP

	local nfilesInReposit=$(wc -l < $CACHEDIR_SEARCH/$PACKAGES_SPLIT)
	local nfilesInstalled=$(wc -l < $CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT)
	local nfilesInCache=$(wc -l < $CACHEDIR_SEARCH/$PACKAGES_IN_CACHE)
	log_msg "${cyan}All list packages updated!${reset}"
	log_msg "${blue}($(strzero $nfilesInReposit 5)) packages in the repository${reset}"
	log_msg "${green}($(strzero $nfilesInstalled 5)) installed packages${reset}"
	log_msg "${green}($(strzero $nfilesInCache 5)) packages in cache $CACHEDIR_ARCHIVES${reset}"
	echo
	log_msg "${reset}Use: # ${0##*/} --help for helping${reset}"
	popd &>/dev/null
}

sh_FilesInCache()
{
	log_msg "Recreating IN CACHE packages list"
	printf "" >| $CACHEDIR_SEARCH/$PACKAGES_IN_CACHE
	local aCache=($(find $CACHEDIR_ARCHIVES/ -iname "*.${PKG_EXT}" -type f))
	local nfilesincache=${#aCache[*]}
   local index=1

   if (( $nfilesincache )); then
      local item
   	for item in ${aCache[*]}; do
       	echo $item >> $CACHEDIR_SEARCH/$PACKAGES_IN_CACHE
         if (( LLIST )); then
            printf "%s\n" "$item"
            ((index++))
         fi
   	done
   fi
   if (( LLIST )); then
      printf "${yellow}($nfilesincache) ${cyan}packages IN CACHE $CACHEDIR_ARCHIVES\n"
   fi
   return $nfilesincache
}

sh_pkgoutcache()
{
	log_wait_msg "Ok, let's do it..."
	log_info_msg "Wait, doing some calculations..."

	sh_FilesInCache "OFF"
	local nfilesincache=${?}
	evaluate_retval

	local aPkgOut=()
	local aRepository=$(_CAT $CACHEDIR_SEARCH/$PACKAGES_SPLIT | cut -d$SEP -f1)
	local x
	local y
	local index=0
	local lfind=$false

	for x in ${aRepository[*]};do
		lfind=$false
		for y in ${aCache[*]};do
			if [ $x = $y ]; then
				lfind=$true
				break
			fi
		done
		if [ $lfind = $false ]; then
			aPkgOut[$index]=$x
			((index++))
		fi
	done
	local nfilesoutcache=${#aPkgOut[*]}
	(( nfilesoutcache != 0 )) || maxcol; replicate "=" $?
   index=1
	for y in ${aPkgOut[*]}
	do
		sh_write "$y" "0" "$index"
		#log_msg "NOT IN CACHE: [$index]${orange}$y${reset}"
		((index++))
	done
	(( nfilesoutcache != 0 )) || maxcol; replicate "=" $?
	echo -e "${yellow}($nfilesincache)  ${cyan}packages in cache"
	echo -e "${yellow}($nfilesoutcache) ${cyan}packages in the repository e out cache"
	return 0
}

sh_CatAndSizePkg()
{
	local cpacote=$1
	local LSHOW=$2
	local retval=0

	source "$cpacote"
	if (( LSHOW )); then
		printf "${cyan}BaseName     : ${yellow}${aPKGSPLIT[$PKG_FOLDER_DIR]}/${aPKGSPLIT[$PKG_FULLNAME]}\n"
		printf "${cyan}Name         : ${yellow}${pkgname}\n"
		printf "${cyan}Version      : ${yellow}${version}\n"
		printf "${cyan}Build        : ${yellow}${build}\n"
		printf "${cyan}Description  : ${yellow}${desc}\n"
		printf "${cyan}Architecture : ${yellow}${arch}\n"
		printf "${cyan}URL          : ${yellow}${url}\n"
		printf "${cyan}Licenses     : ${yellow}${license}\n"
		printf "${cyan}Dependencies : ${yellow}${depend}\n"
		printf "${cyan}Dependencies : ${yellow}${dep}\n"
		printf "${cyan}Size         : ${yellow}$(size_to_human ${size})\n"
		printf "${cyan}Packer       : ${yellow}${maintainer}\n"
		printf "${cyan}Distro       : ${yellow}${distro}\n"
		printf "${cyan}Init         : ${yellow}${lfs_init}\n"
		printf "${cyan}LSB          : ${yellow}${lfs_version}\n"
    	printf "${reset}\n"
	fi
	retval=${size}
	unset pkgname version build desc arch url license depend dep size mainteiner distro lfs_init lfs_version
	return $retval
}

sh_ShortCatPkg()
{
	local cpacote=$1
	local LSHOW=$2
	local retval=0
	local cpackage="${aPKGSPLIT[$PKG_BASE]}"
	local SEARCH_CUT='-f5'
	local pkginstalled=

  	source "$cpacote"
	if (( LSHOW )); then
		pkginstalled=$(grep ^$cpackage$SEP $CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT | cut -d$SEP $SEARCH_CUT)
		if [[ -z $pkginstalled ]]; then
			printf "%s  %s %s\n" "${pink}${aPKGSPLIT[$PKG_FOLDER_DIR]}/${yellow}${aPKGSPLIT[$PKG_BASE]}" "${green}${aPKGSPLIT[$PKG_VERSION]}" "${white}${desc::40}"
		else
			printf "%s  %s %s\n" "${pink}${aPKGSPLIT[$PKG_FOLDER_DIR]}/${yellow}${aPKGSPLIT[$PKG_BASE]}" "${green}${aPKGSPLIT[$PKG_VERSION]}" "${cyan}[installed] ${white}${desc::40}"
		fi
    	printf "${reset}"
	fi
	retval=${size}
	unset pkgname version desc arch url license depend dep size maintainer distro lfs_init lfs_version
	return $retval
}

sh_show()
{
	local param=$@
	local error_value=0
	local saveverbose=$verbose

	if (( verbose >= 2  )); then
		log_msg "Reading package list..."
	fi

	verbose=0
	LDEPS=$false; LEXACT=$true; sh_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" ${param}
	local ntotal_pkg_installed=${public_ntotal_pkg_installed}
	local ntotal_pkg_listed=${public_ntotal_pkg_listed}
	verbose=$saveverbose

	if [[ $public_pkg != "" ]]; then
		for i in $public_pkg; do
			sh_splitpkg ${i}
			local cfullname=${aPKGSPLIT[1]}.desc
			local cBase=${aPKGSPLIT[$PKG_BASE]}
			local cBaseVersion=${aPKGSPLIT[$PKG_BASE_VERSION]}
			local cpacote=${aPKGSPLIT[$PKG_BASE_VERSION]}.desc
			local cVersion=${aPKGSPLIT[$PKG_VERSION]}
			local cBuild=${aPKGSPLIT[$PKG_BUILD]}
	    	local error_value=0

			cpacote=$CACHEDIR_ARCHIVES/$cfullname
			if [[ LFORCE ]] || ! [[ -e ${cpacote} ]]; then
				sh_wgetdesc
	    		error_value="${?}"
			fi

    		if [ ${error_value} = 0 ]; then
				sh_CatAndSizePkg "$cpacote" $true
			else
				if (( verbose < 2 )); then
					log_failure_msg2 "${red}error${reset}: $response NOT FOUND file ${orange}${cfile} ${reset}at $SITE/packages/"
				fi
    		fi
		done
	fi
	sh_cdroot
}

# -R
sh_remove()
{
	local param=$@
	local x
	local cPkgFullFilename

	LDEPS=$false
	LEXACT=$true
	LREMOVE=$true
	sh_listpkgdisp $CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT ${param}
	local ntotal_pkg_installed=${public_ntotal_pkg_installed}
	local ntotal_pkg_listed=${public_ntotal_pkg_listed}

	if (( $ntotal_pkg_listed )); then
		if ! (( LAUTO )); then
			echo
			confno "${blue}::${reset} Remove package(s)?"
			LAUTO=$?
		fi

		if (( LAUTO )); then
			for cPkgFullFilename in $public_pkg
			do
				sh_splitpkg $cPkgFullFilename
				sh_doremove ${aPKGSPLIT[$PKG_BASE_VERSION]} $cPkgFullFilename
			done
		fi
	else
		echo
		#log_failure_msg2 "${red}error${reset}:${orange}${public_ListSearch} ${reset}not installed."
		return $ERR_ERROR
	fi
	return $ERR_OK
}

sh_doremove()
{
	local cPkgBaseVersion=$1
	local cPkgFullFilename=$2

	log_wait_msg "Wait, Removing package ${orange}$cPkgFullFilename"
	if sh_removepkg $cPkgBaseVersion $cPkgFullFilename; then
		if (( LLIST )); then
			log_success_msg2 "${green}$cPkgFullFilename${reset} Done. Removal of the package successfully completed"
		fi
		return $ERR_OK
	fi
	return $ERR_ERROR
}

sh_removepkg()
{
	local cPkgBaseVersion=$1
	local cPkgFullFilename=$2
	local retval=0

	sh_pre_remove $cPkgBaseVersion || return $ERR_ERROR
	sh_splitpkg $cPkgBaseVersion
	retval=$?

	if [[ $retval -eq $ERR_OK ]] ; then
		sed -i  '/'$cPkgBaseVersion'/d' $CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT
	fi
	return $ERR_OK
}

sh_pre_remove()
{
	local cPkgBaseVersion=$1
	local cExtDesc=$cPkgBaseVersion.desc
	local cExtList=$cPkgBaseVersion.list

	AUTO_YES=$true
	[[ -e $CACHEDIR_LIST/$cExtList ]] && { sh_remove_now $cPkgBaseVersion; return $ERR_OK; } || { log_failure_msg2 "Error, file not found: ${red}$CACHEDIR_LIST/$cExtList"; return $ERR_ERROR;}
	sh_subshell_status
}

sh_remove_now()
{
	local cPkgBaseVersion="${1/%.${PKG_EXT}/}"
	local thefile

	pushd "/" &>/dev/null

	if [[ -e "${CACHEDIR_REMO}/${cPkgBaseVersion}.rm" ]]; then
		sed -E "/rm[[:space:]]+\-(rf|fr)/d" "${CACHEDIR_REMO}/${cPkgBaseVersion}.rm" &>/dev/null
		bash "${CACHEDIR_REMO}/${cPkgBaseVersion}.rm"
		rm "${CACHEDIR_REMO}/${cPkgBaseVersion}.rm" &>/dev/null
	fi

	while IFS= read thefile; do
		if [[ -f "$thefile" ]]; then
			rm "$thefile" &>/dev/null && print "Delete\t${thefile}"
		fi
		if [[ -L "$thefile" ]]; then
			unlink "$thefile" &>/dev/null
		fi
		if [[ -d "$thefile" ]] && [[ -z "$(ls -A ${thefile})" ]]; then
			rmdir -p "${thefile}" &>/dev/null
		fi
	done < "${CACHEDIR_LIST}/${cPkgBaseVersion}.list"

	popd &>/dev/null
	IFS=$SAVEIFS

	if ! rm $CACHEDIR_DESC/$cPkgBaseVersion.desc &>/dev/null; then { log_failure_msg2 "Error, It was not possible remove $CACHEDIR_DESC/$cPkgBaseVersion.desc" ; return 1; } fi
	if ! rm $CACHEDIR_LIST/$cPkgBaseVersion.list &>/dev/null; then { log_failure_msg2 "Error, It was not possible remove $CACHEDIR_LIST/$cPkgBaseVersion.list" ; return 1; } fi
	return $ERR_OK
}

sh_pre_removeOLD()
{
	(
	local cPkgBaseVersion=$1
	local nlenstrpkg=${#cPkgBaseVersion}
	local pkgsearch="${cPkgBaseVersion:0:$((nlenstrpkg-2))}"
	local re="\b${pkgsearch}\b"
	local inc=0
	local count_occurrences=0
	local search_pack
	local name_version_build
	local q
	local alldesc=$cPkgBaseVersion.desc

	pushd $CACHEDIR_DESC 1>/dev/null
	for search_pack in $alldesc; do
		if [[ "$search_pack" =~ ^${re}.* ]]; then
			for q in *; do
				if [[ "$q" =~ ^${re}.* ]]; then
					((count_occurrences++))
				fi
			done

			[[ -e $CACHEDIR_DESC/${search_pack} ]] && source $CACHEDIR_DESC/${search_pack}
			name_version_build=$cPkgBaseVersion
			AUTO_YES=$true
			pushd "${CACHEDIR_LIST}" 1>/dev/null
			search_pack="${search_pack/%.desc/.list}" # se terminar com .desc substitua por .list
			[[ -e "${search_pack}" ]] && { sh_remove_now "$name_version_build"; return 0 ;} || { log_failure_msg2 "ERROR: FILE NOT FOUND ${CACHEDIR_LIST}/${search_pack}"; return 1;}
			continue
		else
			((inc++))
		fi
	done

	[[ $inc -gt 0 ]] && { log_failure_msg2 "NOT FOUND ${cPkgBaseVersion}"; return 1 ;}
	)
	sh_subshell_status
}

sh_download()
{
	local param=$@
	local error_value=0
	local nFilesDownloaded=0

	LDEPS=$false; LEXACT=$true; sh_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" ${param}
	local ntotal_pkg_installed=${public_ntotal_pkg_installed}
	local ntotal_pkg_listed=${public_ntotal_pkg_listed}

	if [[ $public_pkg != "" ]]; then
		pushd $CACHEDIR_ARCHIVES/ &>/dev/null

		#internet?
		sh_checknet; [[ $? = $false ]] || { return 1;}

		if (( verbose )); then
			log_msg "Downloading package..."
		fi

		for i in $public_pkg; do
			local nTotalFiles=$ntotal_pkg_listed
			local cspace=$(printf "%20s" ' ')
			sh_splitpkg $i
			local cfullname="${aPKGSPLIT[$PKG_FULLNAME]}"

    		if (( LFORCE )); then
				sh_wgetdesc $i
				sh_wgetfull $i
				[[ $? -eq 0 ]] && (( nFilesDownloaded++ ))
			else
			 	if test -e $CACHEDIR_ARCHIVES/$cfullname; then
 					log_failure_msg2 "${orange}${i##*/} ${reset}Package is already downloaded. Use the -f option to force download."
				else
					sh_wgetdesc $i
					sh_wgetfull $i
					[[ $? -eq 0 ]] && (( nFilesDownloaded++ ))
				fi
			fi
		done
		log_msg "${cyan}($nFilesDownloaded) packages(s) downloaded."
		popd &>/dev/null
	fi
}

sh_getdeps()
{
	local ncontadep=0
	local ncontapkgdep=0
	local	arr
	local pkgNumber=0
   local cfullfilename
   local x
   local LDEPS=$1

	if (( verbose >= 2 )); then
		log_msg "${cyan}solving dependencies..."
	fi

	deps=''
  	GETDEPS=''

   for i in $public_pkg
	do
		sh_splitpkg $i
		cbase=${aPKGSPLIT[PKG_BASE]}
		cfullfilename=${aPKGSPLIT[PKG_FULLNAME]}
	   test -e $CACHEDIR_ARCHIVES/$cfullfilename.desc || sh_wgetdesc
		if test -e $CACHEDIR_ARCHIVES/$cfullfilename.desc; then
	   	source $CACHEDIR_ARCHIVES/$cfullfilename.desc
			if (( LDEPS )); then
	   	  	deps="${dep[*]} "
      		deps+="$(grep ^depend $CACHEDIR_ARCHIVES/${cfullfilename}.desc | awk -F"'" '{print $2}')"
      	fi
		fi
   done

  	sh_adel "$deps"
  	ncontapkgdep=$(lenarraystr "$deps")

  	for i in ${deps[@]}
  	do
  		((ncontadep++))
  		pkgdep=$(grep ^$i$SEP $CACHEDIR_SEARCH/$PACKAGES_SPLIT | awk -F$SEP '{print $5}')
  		if [[ -z $pkgdep ]]; then
			if (( verbose )); then
  				printf "${red}%s(%04d) ${orange}%-40s ${reset}%-40s\n" "     " "$ncontadep" "${i}" "WARNING! Dependency not found in the database. ${reset}Use: # fetch -Sy to update with the repository${reset}"
			fi
  		else
 			GETDEPS+="$pkgdep "
			pkginstalled=$(grep ^$i$SEP $CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT | awk -F$SEP '{print $5}')
	  		if [[ -z $pkginstalled ]]; then
				#GETDEPS+="$pkgdep "
				echo
	  		fi
  		fi
  	done
  	public_pkg_deps=$GETDEPS
   return $?
}

sh_wgetresponse()
{
	local i="$1"
	local cfile=${i##*/}
	local cfullfilename=$CACHEDIR_ARCHIVES/$cfile
	export response

	if (( verbose >= 2 )); then
		log_msg "${DOT}${cyan}Fetching package ${cRaw}/packages/${orange}${i}"
		response=$(curl -w "%{http_code}\n" -k -O "${cRaw}/packages/$i")
	else
		response=$(curl -s -w "%{http_code}\n" -k -O "${cRaw}/packages/$i")
	fi

	if [[ $response -eq 404 ]]; then
		rm -f $cfullfilename &> /dev/null

		if ! (( LSKIPERROR )); then
			log_failure_msg "${red}error${reset}: $response NOT FOUND file ${orange}${cfile} ${reset}at $SITE/packages/ - Use the ${yellow}--skiperror ${reset}option to force install. "
			exit 1
		else
			if (( verbose >= 2 )); then
				log_failure_msg2 "${red}error${reset}: $response NOT FOUND file ${orange}${cfile} ${reset}at $SITE/packages/"
			fi
		fi
		return 1
	fi
	return 0
}

sh_wgetdesc()
{
	local cfullfilename=$1
	local cRaw
   local nretval

	if ! (( $GITSITE )); then
		cRaw=$SITE 	#site normal
	else
		cRaw=$RAW	#github
	fi
	pushd $CACHEDIR_ARCHIVES/ &>/dev/null
	sh_wgetresponse "${i}.desc"
	nretval=$?
	popd &>/dev/null
	return $nretval
}

sh_wgetfull()
{
	local cfullfilename=$1
	local cRaw
   local nretval

	if ! (( $GITSITE )); then
		cRaw=$SITE	#site normal
	else
		cRaw=$RAW	#github
	fi
	sh_wgetresponse $i
	nretval=$?
	return $nretval
}

sh_wgetpartial()
{
	local cfullfilename=$1
	local cRaw

	if ! (( $GITSITE )); then
		cRaw=$SITE	#site normal
	else
		cRaw=$RAW	#github
	fi

	if ! test -e $CACHEDIR_ARCHIVES/$cpacote; then
		sh_wgetresponse $i
	fi

	if ! test -e $CACHEDIR_ARCHIVES/$cpacote.desc; then
		sh_wgetresponse $i.desc
	fi
	return $?
}

sh_checksha256sum()
{
	log_info_msg "Checking sha256sum..."
	ERROR=$(sha256sum -c ${cpacote}.sha256 2>&1>/dev/null)
	evaluate_retval
	return $?
}

sh_splitpkg()
{
	file=$1
	aPKGSPLIT=()

	pkg_folder_dir=${file%/*}										#remove arquivo deixando somente o diretorio/repo
	pkg_fullname=${file##*/}			    						#remove diretorio deixando somente nome do pacote

   [[ $pkg_folder_dir == $pkg_fullname ]] && pkg_folder_dir="localhost"
	if [[ $pkg_fullname =~ $PKG_RE ]] ; then
		pkg_fullname="${BASH_REMATCH[0]}"
		pkg_base="${BASH_REMATCH[1]}"
		pkg_version_build="${BASH_REMATCH[2]}"
		pkg_version="${BASH_REMATCH[3]}"
		pkg_build="${BASH_REMATCH[4]}"
		pkg_arch="${BASH_REMATCH[5]}"
		pkg_base_version="${pkg_base}-${pkg_version_build}"

		#debug "$pkg_base \n $pkg_version_build \n $pkg_version \n $pkg_build \n $pkg_arch \n $pkg_base_version \n"
		: '
		  debug " file            : $file\n" \
		        "pkg_folder_dir  : $pkg_folder_dir\n" \
			 	  "pkg_fullname    : $pkg_fullname\n" \
			 	  "pkg_arch        : $pkg_arch\n" \
			 	  "pkg_base        : $pkg_base\n" \
				  "pkg_base_version: $pkg_base_version\n" \
				  "pkg_version     : $pkg_version\n" \
				  "pkg_build       : $pkg_build"
		'
		aPKGSPLIT=(	"$pkg_folder_dir"
					  	"$pkg_fullname"
						"$pkg_arch"
						"$pkg_base"
						"$pkg_base_version"
						"$pkg_version-$pkg_build"
						"$pkg_build"
						)
	fi
	return $?
}

sh_splitpkgIFS()
{
	local file=$1
	local pkg_folder_dir
	local pkg_fullname
	local pkg_arch
	local pkg_base
	local pkg_base_version
	local pkg_version
	local pkg_build
	local pkg_str
	local nconta=0
	local char='-'
	local var
	local ra
	local re

	aPKGSPLIT=()
	pkg_folder_dir=${file%/*}										#remove arquivo deixando somente o diretorio/repo
	pkg_fullname=${file##*/}			    						#remove diretorio deixando somente nome do pacote
	pkg_arch=${pkg_fullname%.${PKG_EXT}*}						#remove extensao pacote (chi.zst/mz)
	pkg_arch=${pkg_arch%.arch1*}			 						#remove extensao pacote (chi.zst/mz)
	pkg_arch=${pkg_arch##*-}			 							#remove do começo até o ultimo -

	pkg_str=${pkg_fullname%-any.${PKG_EXT}*} 					#remove extensao pacote (chi.zst/mz)
	pkg_str=${pkg_str%.${PKG_EXT}*} 								#remove extensao pacote (chi.zst/mz)
	pkg_str=${pkg_str%-x86_64*}			 						#remove extensao pacote (chi.zst/mz)
	pkg_str=${pkg_str%.${PKG_EXT}*}  							#remove extensao pacote (chi.zst/mz)

	IFS='-'
	read -ra ADDR <<< "$pkg_str"									# str is read into an array as tokens separated by IFS
	for var in "${ADDR[@]}"; do 									# access each element of array
		re='^[a-zA-Z]'
		if [[ "$var" =~ $re ]]; then
			pkg_base="$pkg_base${var}$char"
		else
			((nconta++))
			[[ $nconta -eq 1 ]] && pkg_version=$var || pkg_build=$var
		fi
	done
 	IFS=$SAVEIFS
	pkg_base=${pkg_base%-*}
	pkg_version="${pkg_version}"
	pkg_base_version="${pkg_base}-${pkg_version}-${pkg_build}"
	[[ $pkg_folder = "" ]] && pkg_folder=$pkg_fullname

	aPKGSPLIT=(	"$pkg_folder_dir"
					"$pkg_fullname"
					"$pkg_arch"
					"$pkg_base"
					"$pkg_base_version"
					"$pkg_version-$pkg_build"
					"$pkg_build"
				)

#	aPKGLIST=${aPKGSPLIT[*]}
#	arr=(${aPKGSPLIT[*]})
	return $?
}

sh_splitpkgawk()
{
	file=$1
	aPKGSPLIT=()

	pkg_folder_dir=${file%/*}							#remove arquivo deixando somente o diretorio/repo
	pkg_fullname=${file##*/}    						#remove diretorio deixando somente nome do pacote

	arr=($(echo $pkg_fullname | awk 'match($0, /(.+)-(([^-]+)-([0-9]+))-([^.]+)\.chi\.zst/, array) {
			print array[0]
			print array[1]
			print array[2]
		   print array[3]
		   print array[4]
    		print array[5]
    		print array[6]
			}'))

	pkg_fullname="${arr[0]}"
	pkg_base="${arr[1]}"
	pkg_version_build="${arr[2]}"
	pkg_version="${arr[3]}"
	pkg_build="${arr[4]}"
	pkg_arch="${arr[5]}"
	pkg_base_version="${arr[0]}-${arr[4]}"

	aPKGSPLIT=(	$pkg_folder_dir
					$pkg_fullname
					$pkg_arch
					$pkg_base
					$pkg_base_version
					$pkg_version-$pkg_build
					$pkg_build
				)
	return $?
}

# -S
sh_install()
{
	local param="$@"

	[[ $verbose -eq 0 ]] && (( verbose=1 ))
	sh_listpkgdisp	"$CACHEDIR_SEARCH/$PACKAGES_SPLIT" ${param}
	local ntotal_pkg_installed=${public_ntotal_pkg_installed}
	local ntotal_pkg_listed=${public_ntotal_pkg_listed}

	if [[ $public_pkg != "" ]]; then
		[[ -d $CACHEDIR_ARCHIVES/ ]] || mkdir -p $CACHEDIR_ARCHIVES/
		cd $CACHEDIR_ARCHIVES/

		if ! (( LAUTO )); then
			echo
			read -e -p "${blue}:: ${reset}Continue installation? [Y/n]" LDOWNLOAD
			if [[ $(toupper "${LDOWNLOAD}") = "N" ]]; then
				return
			fi
		fi
      sh_installdownload
      sh_installdoinstallpkg
	fi
	sh_cdroot
}

sh_installdownload()
{
	for i in $public_pkg; do
		sh_splitpkg $i
		local cfullfilename=${aPKGSPLIT[PKG_FULLNAME]}
		local cpacote=${aPKGSPLIT[PKG_FULLNAME]}
		local cpacotebase=${aPKGSPLIT[PKG_BASE]}
		test -e $CACHEDIR_ARCHIVES/$cpacote || sh_wgetpartial $i
		local error_value=$?
		if [ ${error_value} -ne 0 ]; then
			log_failure_msg2 "ERROR: Downloading ${orange}${cfullfilename}"
			log_wait_msg "Restarting download ${orange}${cfullfilename}"
			sh_wgetfull
			local error_value=$?
			if [ ${error_value} -ne 0 ]; then
				log_failure_msg2 "ERROR: Fatal error downloading ${orange}${cfullfilename}. ${reset}"
				exit 1
			fi
		fi
	done
}

sh_installdoinstallpkg()
{
	local LINSTALLED=$false

	for i in $public_pkg; do
		sh_splitpkg $i
		local cfullfilename=${aPKGSPLIT[PKG_FULLNAME]}
		local cpacote=${aPKGSPLIT[PKG_FULLNAME]}
		local cpacotebase=${aPKGSPLIT[PKG_BASE]}
		local cBaseVersion=${aPKGSPLIT[$PKG_BASE_VERSION]}

		case $cpacotebase in
			gcc)	      log_failure_msg2 "Skipping package: $cpacotebase"; continue;;
			gcc-libs)   log_failure_msg2 "Skipping package: $cpacotebase"; continue;;
			glibc)	   log_failure_msg2 "Skipping package: $cpacotebase"; continue;;
			file)	      log_failure_msg2 "Skipping package: $cpacotebase"; continue;;
			flac)	      log_failure_msg2 "Skipping package: $cpacotebase"; continue;;
		esac

		local cpacoteinstalled=$(grep ^$cpacotebase$SEP ${CACHEDIR_SEARCH}/$PACKAGES_INSTALLED_SPLIT | cut -d$SEP -f6)
		[[ "$cpacoteinstalled" == "$cBaseVersion" ]] && LINSTALLED=$true || LINSTALLED=$false
		if (( LINSTALLED )) && ! (( LFORCE )); then
			log_failure_msg2 "${orange}${cBaseVersion} ${reset}Package is already installed. Use the -f option to force reinstallation."
			continue
		fi
		sh_installpkg $cpacote
		local error_value=$?
		if [ $error_value -eq 0 ]; then
			log_success_msg2 "${green}${cpacote} ${reset}Done. package installation successfully."
		fi
	done
}

# -Ss
sh_search()
{
	local oldverbose=$verbose
	local param=$@

	[[ $verbose -gt 1 ]] || (( verbose=0 ))
	LDEPS=$false; sh_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" $param
	local ntotal_pkg_installed=$public_ntotal_pkg_installed
	local ntotal_pkg_listed=$public_ntotal_pkg_listed

	if [[ $public_pkg != "" ]]; then
		for i in $public_pkg; do
			sh_splitpkg $i
			local cfullname=${aPKGSPLIT[1]}.desc
			local cBase=${aPKGSPLIT[$PKG_BASE]}
			local cBaseVersion=${aPKGSPLIT[$PKG_BASE_VERSION]}
			local cpacote=${aPKGSPLIT[$PKG_BASE_VERSION]}.desc
			local cVersion=${aPKGSPLIT[$PKG_VERSION]}
			local cBuild=${aPKGSPLIT[$PKG_BUILD]}
			local	error_value=0

			cpacote=$CACHEDIR_ARCHIVES/$cfullname
			if [[ LFORCE = $true ]] || ! [[ -e $cpacote ]]; then
				sh_wgetdesc
	    		error_value=$?
			fi

    		if [[ $error_value = 0 ]]; then
				sh_ShortCatPkg "$cpacote" $true
    		else
				if (( verbose < 2 )); then
					log_failure_msg2 "${red}error${reset}: $response NOT FOUND file ${orange}${cfullname} ${reset}at $SITE/packages/"
				fi
			fi
		done
	fi
	verbose=$oldverbose
}

sh_listmeta()
{
	local param=$@
	local cListSearch=$param
	local x
	local arr
	public_ntotal_pkg_meta=0

	LLIST=$true
	if (( verbose >= 2 )); then
		log_msg "Reading meta package lists in the repository..."
	fi

	if (( LALL )) || [[ -z "$cListSearch" ]]; then
		if (( LALL )); then
			metapkg=$(cat $CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES)
		else
			log_failure_msg2 "${red}error${reset}: nenhum alvo definido (use -h para obter ajuda)"
			exit 1
		fi
	else
		for x in $cListSearch; do
			if (( LEXACT )); then
				cfile="$(grep "\/$x.meta$" $CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES)"
				metapkg="$metapkg $(echo $cfile)"
			else
				cfile="$(grep $x $CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES)"
				metapkg="$metapkg $(echo $cfile)"
			fi

			if [[ -z $cfile ]]; then
				if ! (( LSKIPERROR )); then
					log_failure_msg "${red}error${reset}: ${orange}${x} ${reset}target was ${red}NOT ${reset}found. Use the ${yellow}--skiperror ${reset}option to force install. "
					exit 1
				else
					log_failure_msg "${red}error${reset}: ${orange}${x} ${reset}target was ${red}NOT ${reset}found. ${yellow}Skipping"
				fi
			fi
		done
	fi

	arr=(${metapkg[*]})
	public_ntotal_pkg_meta=${#arr[*]}

	if (( $public_ntotal_pkg_meta )); then
		if (( verbose >= 2 )); then
			log_msg "Listing... Done"
		fi
		for i in $metapkg; do
			[[ $LLIST = $true ]] && log_success_msg2 "${blue}FOUND ${orange}$i"
		done
		[[ $LLIST = $true ]] && log_success_msg2 "($public_ntotal_pkg_meta) meta package(s) found."
	else
		 log_failure_msg2 "${red}error: ${reset}target not found : ${orange}${param}"
	fi
	return $public_ntotal_pkg_meta
}

sh_installmeta()
{
	local param="$@"
	local pkgInMeta=()

	sh_listmeta $param
	public_ntotal_pkg_meta=$?

	if (( $public_ntotal_pkg_meta )); then
		if ! (( LAUTO )); then
			echo
			read -e -p "$(DOT)continue installation? [Y/n]" LDOWNLOAD
			if [[ $(toupper "${LDOWNLOAD}") = "N" ]]; then
				return
			fi
			LAUTO=$true
		fi

		pushd $CACHEDIR_ARCHIVES/ &>/dev/null
		for cmetafile in $metapkg; do
			local cmetabase=$(echo $cmetafile | cut -d/ -f1)
			local cmetapackage=$(echo $cmetafile | cut -d/ -f2)

			if ! (( $GITSITE )); then
            curl --silent -k -O "${SITE}/packages/$cmetafile"
			else
				curl --silent -k -O "${RAW}/packages/$cmetafile"
			fi
			pkgInMeta="$pkgInMeta $(cat $CACHEDIR_ARCHIVES/$cmetapackage)"
		done

		popd &>/dev/null
		param=$pkgInMeta

#		[[ $verbose -eq 0 ]] && (( verbose=1 ))
		verbose=0
		sh_listpkgdisp	"$CACHEDIR_SEARCH/$PACKAGES_SPLIT" ${param}
		local ntotal_pkg_installed=${public_ntotal_pkg_installed}
		local ntotal_pkg_listed=${public_ntotal_pkg_listed}

		if [[ $public_pkg != "" ]]; then
			[[ -d $CACHEDIR_ARCHIVES/ ]] || mkdir -p $CACHEDIR_ARCHIVES/
			cd $CACHEDIR_ARCHIVES/

			if ! (( LAUTO )); then
				echo
				read -e -p "${blue}:: ${reset}Continue installation? [Y/n]" LDOWNLOAD
				if [[ $(toupper "${LDOWNLOAD}") = "N" ]]; then
					return
				fi
			fi
	      sh_installdownload
	      sh_installdoinstallpkg
		fi
		sh_cdroot
	fi
}

sh_recreateFilesFromArch()
{
	local item

	log_msg "Fixing packages installed by pacman"
	pushd /var/lib/pacman/local/ &> /dev/null
	local aCache=$(printf '%s\n' *)
	local nfiles=$(lenarray "$aCache")
	popd &> /dev/null

   if (( $nfiles )); then
   	for item in $aCache; do
   		[[ $item == 'ALPM_DB_VERSION' || $item == ',,,,' || -z $item ]] && continue;
			[[ -f $CACHEDIR_DESC/$item.desc ]] || >| $CACHEDIR_DESC/$item.desc &> /dev/null
   	done
   fi
	return $nfiles
}

# -Sr
sh_recreatefilepackagesinstalled()
{
	local re='(.+)-(([^-]+)-([0-9]))+[.](desc)$'
	local item
	local package
   local pkgNumber=0

	log_msg "Recreating installed packages list"
	sh_recreateFilesFromArch
	log_msg "Reading lists of installed packages"

	>| "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" &> /dev/null
#1	local aCache=$(printf '%s\n' $CACHEDIR_DESC/* | awk -F "$re" 'list[$1]++')
#2	local aCache=$(grep -Po "$re" < <(printf '%s\n' $CACHEDIR_DESC/*) )
	local aCache=$(find $CACHEDIR_DESC/ -regextype posix-egrep -regex "$re" -type f | sort -V)
	local nfiles=$(lenarray "$aCache")

   if (( $nfiles )); then
		log_msg "Checking installed packages"
		sh_arraypkgfull
		if (( verbose >= 2 )); then
			sh_cabec $nfiles
		fi

   	for item in $aCache; do
			[[ -z $item ]] && continue;
 	     	package=${item##*/}
			package=${package%.desc*}
   		sh_ascanpkg $package '5'
	      cline=$(clineascan)

			if (( verbose >= 2 )); then
				sh_write $cbase '0' $((++pkgNumber))
			fi

			echo $cline >> $CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT
   	done
   fi
   log_msg "${yellow}($nfiles) ${cyan}packages installed\n"
	return $nfiles
}

# -Qq
sh_totalpackagesinstalled()
{
	if (( verbose >= 2 )); then
		awk -F "," '{print $1}' $CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT
	else
#		awk 'END {print NR}' $CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT
		sh_linecount $CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT
	fi
}

sh_listforinstall()
{
	local pkgNumber=0
	local s
	local param=$@
	local LLIST=$true
	local LEXACT=$false
	local LALL=$false
	local LDEPS=$true
	local ncontapkg=0
	local cListSearch
	local arr

	[[ -e $CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT ]] || printf '' > "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"
	public_ntotal_pkg_installed=$(sh_linecount $CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT)
	public_ntotal_pkg_listed=$public_ntotal_pkg_installed
	public_pkg=

	for s in ${param[@]}; do
		cListSearch+="$s "
	done

	if (( LALL )) || [[ -z "$cListSearch" ]]; then
		if (( LALL )); then
			public_pkg=$(grep ^ $CACHEDIR_SEARCH/$PACKAGES_SPLIT | cut -d$SEP -f5)
		else
			log_failure_msg2 "${red}error${reset}: nenhum alvo definido (use -h para obter ajuda)"
			exit 1
		fi
	else
		for x in $cListSearch; do
			if (( LEXACT )); then
				if [[ "$SPLITPOS" == "0" ]]; then
					public_pkg="$public_pkg $(grep ^$x: $CACHEDIR_SEARCH/$PACKAGES_SPLIT | cut -d$SEP -f1)"
				else
					public_pkg="$public_pkg $(grep ^$x: $CACHEDIR_SEARCH/$PACKAGES_SPLIT | cut -d$SEP -f5)"
				fi
			else
				if [[ "$SPLITPOS" == "0" ]]; then
					public_pkg="$public_pkg $(grep $x $CACHEDIR_SEARCH/$PACKAGES_SPLIT | cut -d$SEP -f1)"
				else
					public_pkg="$public_pkg $(grep $x $CACHEDIR_SEARCH/$PACKAGES_SPLIT | cut -d$SEP -f5)"
				fi
			fi
		done
	fi

	if (( LLIST )); then
   	arr=(${public_pkg[*]})
   	ncontapkg=${#arr[*]}
		if [[ "${#public_pkg}" -gt 0 ]]; then # pacote?
			pkgNumber=0
  			sh_getdeps $LDEPS
      	arr=(${public_pkg[*]})
      	ncontapkg=${#arr[*]}
			public_ntotal_pkg_listed=$ncontapkg
		else
			log_msg "($pkgNumber) package(s) found."
			echo
			echo -e "${reset}Use: # ${APP} -Sy - to update with the repository${reset}"
		fi
	else
		pkgNumber=0
		for i in $public_pkg; do
			((pkgNumber++))
		done
		public_ntotal_pkg_listed="$pkgNumber"
	fi
	sh_cdroot
	return "$pkgNumber"
}

sh_list_archives_directories()
{
	local packname="${1}.list"
	local LIST_CLEAN_DIRECTORIES

	sed -i "
        s/^\.\///g
        s/^\///g
        s|\/$||g
        /^\./d
        /^ *$/d
        /^bin$/d
        /^info$/d
        /^boot$/d
        /^dev$/d
        /^etc$/d
        /^home$/d
        /^lib$/d
        /^lib64$/d
        /^media$/d
        /^mnt$/d
        /^opt$/d
        /^proc$/d
        /^root$/d
        /^run$/d
        /^sbin$/d
        /^srv$/d
        /^sys$/d
        /^tmp$/d
        /^usr$/d
        /^var$/d
        /^info\/pos\.sh$/d
        /^info\/pre\.sh$/d
        /^info\/desc/d
        /info\/rm.sh/d
        /^var\/lib\/banana\/list\/.*\.list/d
        /^var\/lib$/d
        /^var\/lib\/banana/d
        /^var\/lib\/banana\/list/d
        /^var\/lib\/banana\/remove/d
	" "${CACHEDIR_LIST}/${packname}"

	LIST_CLEAN_DIRECTORIES=(
		'var'
		'lib'
		'media'
		'usr'
		'usr/share'
		'srv'
	)

	while read view; do
		if [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[0]}/(cache|lib|local|lock|log|mail|opt|run|spool|tmp)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${CACHEDIR_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[1]}/(lib64)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${CACHEDIR_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[2]}/(cdrom|floppy)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${CACHEDIR_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[3]}/(bin|etc|lib|lib\/(pkgconfig)|local|share|doc|include|libexec|sbin|src)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${CACHEDIR_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[4]}/(keymaps|fonts|pixmaps|applications|doc|man|man\/man[[:digit:]]+|man\/.{2})$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${CACHEDIR_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[5]}/(www|httpd)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^${view}$/d" "${CACHEDIR_LIST}/${packname}"
		fi
	done < "${CACHEDIR_LIST}/${packname}"
}

sh_subshell_status()
{
	[[ "$?" -ne '0' ]] && return 1 || return 0
}

sh_manage_scripts_and_archives()
{

#	sh_splitpkg "${1}"
   local packname=${aPKGSPLIT[$PKG_BASE_VERSION]}
	local dir_desc="${CACHEDIR_LIST/list/desc}"

	if ! [[ -e "/tmp/info/desc" ]]; then
		log_failure_msg2 "ERROR! /info/desc does not exist. ABORT!"
		return 1
	fi

	pushd "/tmp/info/" &>/dev/null

	if ! mv '/tmp/info/desc' "$CACHEDIR_DESC/${packname}.desc" ; then
		log_failure_msg2 "ERROR! could not move desc to /${dir_desc}/${packname}.desc"
		return 1
	fi

	if [[ -e "/tmp/info/pos.sh" ]]; then
		log_msg "running pos.sh hook"
		bash "/tmp/info/pos.sh"
	fi

	if [[ -e "/tmp/info/.INSTALL" ]]; then
		source /tmp/info/.INSTALL &> /dev/null
		log_msg "running post_install hook"
		post_install &> /dev/null
		log_msg "running post_upgrade hook"
		post_upgrade &> /dev/null
	fi

	if [[ -e "/tmp/info/rm.sh" ]]; then
		if ! mv '/tmp/info/rm.sh' "$CACHEDIR_REMO/${packname}.rm" ; then
			log_failure_msg2 "ERROR! could not move rm.sh to $CACHEDIR_REMO/${packname}.rm"
			return 1
		fi
    fi

	popd &>/dev/null
	[[ -d "/info/"      ]] && rm -r "/info/"
   [[ -d '/tmp/info/'  ]] && rm -r "/tmp/info/"
   [[ -e '/.BUILDINFO' ]] && rm "/.BUILDINFO"
   [[ -e '/.MTREE'     ]] && rm "/.MTREE"
   [[ -e '/.PKGINFO'   ]] && rm "/.PKGINFO"
   [[ -e '/.INSTALL'   ]] && rm "/.INSTALL"
	return 0
}

sh_create_list()
{
	local packname=$1

	if ! tar	--use-compress-program=zstd --force-local --list --file "$packname" > "${CACHEDIR_LIST}/${name_version_build}.list"; then
		log_failure_msg2 "ERROR! Can not create ${CACHEDIR_LIST}/${name_version_build}.list"
		return 1
	fi
	return 0
}

sh_input_null_parameter()
{
	pkg=$1

	local arr
	if [[ -z "$pkg" ]]; then
		pkg=$(echo $PWD | sed 's/\// /g' | awk '{print $NF}'|sed 's/-/_/g'| sed 's/\(.*\)_/\1 /'|sed 's/ /-/g')
		arr=($pkg)
		[[ ${#arr[*]} -gt 2 ]] && pkg="${arr[0]}_${arr[1]} ${arr[2]}"
		pkg=${pkg}-${DESC_BUILD}
	fi
	sh_info "INPUT_NULL" $pkg
	return 0
}

sh_name_format_pkg()
{
	local packname="$1"

	re="\b${PKG_EXT}\b"
	if ! [[ "$packname" =~ .*\.${re}$ ]]; then
		log_failure_msg2 "ERROR Package need finish .${PKG_EXT}"
		return 1
	fi
	return 0
}

_GENERATE_DESC()
{
	local i
	local DESC_PACKNAME=$1
	local DESC_VERSION=$2
	local DESC_BUILD=$3
   local field_pkgver=$4
   local field_pkgrel=$5
	#DESC=$(echo "${DESC//\'}") 		# remove apostrofe. ex: let´s => lets
	DESC=${DESC//\'} 						# remove apostrofe. ex: let´s => lets

	[[ ! -d "info" ]] && mkdir info &> /dev/null

	if [ -e info/desc ]; then
		(( ncount++ ))
		if ! (( LFORCE )); then
			if (( verbose >= 2 )); then
				log_msg "$(fmt)${orange} info/desc ${reset}already exist. Skipping... Use the -f option to force recreate."
			fi
			return
		else
			if (( verbose >= 2 )); then
				log_msg "$(fmt)${orange} info/desc ${reset}already exist. Rewriting"
			fi
		fi
	fi
	_CAT > "info/desc" << EOF
######################################################################
# Generated with fetch    - https://chilinux.com
# Generated with alienpkg - https://chilinux.com
######################################################################
maintainer='$MAINTAINER'
pkgname='$DESC_PACKNAME'
version=$DESC_VERSION
build=$DESC_BUILD
pkgver=$field_pkgver
pkgrel=$field_pkgrel
license='$LICENSE'
lfs_version='$LFS_VERSION'
lfs_init='$LFS_INIT'
arch='$ARCH'
distro='$DISTRO'
desc='$DESC'
pkgdesc='$DESC'
size='$SIZE'
url='$URL'
source=('')
dep=('')
EOF

	for i in ${deps[*]}
	do
		echo depend="'$i'" >> $DESCME
	done
	return 0
}

sh_doinstallpkg()
{
	(
	local packname=$1
	local name_version_build
	local tmp_pack
	local PRE_SH='info/pre.sh'
	local INSTALL_SH='info/.INSTALL'

	tar --dereference                      \
				--force-local                 \
				--use-compress-program=zstd   \
				--extract                     \
				--preserve-permissions        \
				--touch                       \
				--file "${packname}" -C "/tmp/" "./${DESCME}" "./${PRE_SH}" "./${INSTALL_SH}" &>/dev/null

	if [[ ! -e "/tmp/${DESCME}" ]]; then
		log_failure_msg2 "${red}ERROR! ${reset}I could not untar the file: ${orange}${packname}.desc${reset}"
		return 1
	fi
	source "/tmp/${DESCME}" ||	log_failure_msg2 "ERROR! could not load /tmp/${DESCME}. Archive not exist. ABORT!"

	if [[ -e "/tmp/${PRE_SH}" ]]; then
		log_msg "running pre.sh hook"
		bash "/tmp/${PRE_SH}"
	fi

	if [[ -e "/tmp/${INSTALL_SH}" ]]; then
		log_msg "running .INSTALL hook"
		bash "/tmp/${INSTALL_SH}"
	fi

	#name_version_build="${pkgname}-${version}-${build}"
	sh_splitpkg ${packname}
	name_version_build=${aPKGSPLIT[$PKG_BASE_VERSION]}
	tar 	--dereference 						\
			--force-local 						\
			--use-compress-program=zstd	\
			--extract 							\
			--preserve-permissions 			\
			--touch 								\
			--file "${packname}" -C / | tee -a ${CACHEDIR_LIST}/"${name_version_build}.list" || return 1

	sh_create_list "$1" || return 1
	sh_manage_scripts_and_archives "${packname}" || return 1
	sh_list_archives_directories "${name_version_build}"
	)
	sh_subshell_status
}

# -Sl
sh_initinstallpkg()
{
	local pkg=
	local param=$@
	local package
	local arr=
	local nfiles=

	if ! (( LALL )); then
		test $# -lt 1 && die "Missing value for the required argument '$param'. ${yellow}Try ${0##*/} -Sl <package>" 1; _arg_unit="$2"
	fi

	shopt -s nullglob       # enable suppress error message of a command
	if (( LALL )); then
		pkg="$pkg $(find "$PWD/" "$CACHEDIR_ARCHIVES/" -type f -iname "*.${PKG_EXT}")"
	else
		for s in ${param[@]}; do
			cfile=$(echo $s | sed 's/\// /g' | awk '{print $NF}')
			pkg="$pkg $(find "$PWD/" "$CACHEDIR_ARCHIVES/" -type f -iname "*.${PKG_EXT}" | grep "$cfile")"
		done
	fi

	pkgCheckNumber=0
	LLIST=$true
	arr=(${pkg[*]})
	nfiles=${#arr[*]}

	if (( $nfiles )); then # pacote?
		for i in $pkg; do
			[[ $LLIST = $true ]] && log_success_msg2 "${blue}FOUND local package ${orange}$i"
			((pkgCheckNumber++))
		done

		if (( $pkgCheckNumber )); then
			if ! (( LAUTO )); then
				echo
				conf "$(DOT)continue installation?"
				LAUTO=$?
			fi
		fi

		if (( LAUTO )); then
			for package in $pkg
			do
				log_wait_msg "Installing local package ${orange}$package"
				sh_installpkg $package
			done
		fi
	else
		msg "${orange}$param ${red}NOT FOUND ${reset}local package in ${orange}${CACHEDIR_ARCHIVES}${reset}"
		msg "${orange}$param ${red}NOT FOUND ${reset}local package in ${orange}${PWD} ${reset}"
		printf "${reset}Use: # ${0##*/} -Sy to update with the repository${reset}\n"
	fi
	shopt -u nullglob       # disable suppress error message of a command
}

sh_installpkg()
{
	while [[ -n "$1" ]]; do
      local fullname=${1}
      local package=${fullname##*/}  				## tira o path
		sh_doinstallpkg "$fullname" || return 1
		local erro=$?

		if ! (( erro )); then
         sh_splitpkg $fullname
			local cfileinstalled=${aPKGSPLIT[$PKG_BASE_VERSION]}
			local _pkg=${aPKGSPLIT[$PKG_BASE_VERSION]}
			cline=$(clinesplit)
			if ! (( erro )); then
				sed -i '/'${_pkg}'/d' $CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT
				echo "${cline}" >> $CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT
			fi
		fi
		shift
	done
	return $erro
}

_GPG_SIGN()
{
	local package=$1
	local sig='sig'

	#Pacote existe?
	if [[ ! -e "${package}.${PKG_EXT}" ]]; then
		printf "${red}[ERRO]${end} Unable to sign package. ${package}.${PKG_EXT}\n"
		printf "Reason: Package not found.\n"
		printf "For security reasons, do not pass the package on to third parties.\n"
		return 1
	fi

	[ "$REWRITE_SIGN" = "1" ] && rm -f ../${package}.${PKG_EXT}.${sig}
	[ "$REWRITE_SIGN" = "1" ] && rm -f ${package}.${PKG_EXT}.${sig}

	which gpg &> /dev/null
	if [ $? = 0 ]; then
		#Gerando Assinatura no pacote
		gpg --detach-sign --pinentry-mode loopback "${package}.${PKG_EXT}" &>/dev/null || \
		gpg --detach-sign "${package}.${PKG_EXT}" || return 1
		echo -e "${blue}[Create]${end} Your ${sig} on:   ../${package}.${PKG_EXT}.${sig}"
	fi
	return 0
}

sh_verify_on()
{
	local package=$1
   local dir_info='info'
	local info_desc='desc'

	if [[ ! -d "$dir_info" ]]; then
		log_failure_msg2 "${red}[ERROR!]${end} ${pink}${dir_info}${end} directory\n"
		log_failure_msg2 "It's necessary your package have the DIRECTORY ${pink}info${end}."
		log_failure_msg2 "${pink}${dir_info}${end} its a directory store important archives."
		log_failure_msg2 "For more information use -h, --help."
		exit 77
	elif [[ ! -e "${dir_info}/${info_desc}" ]]; then
		log_failure_msg2 "${red}[ERROR!]${end} ${pink}${info_desc}${end} archive\n"
		log_failure_msg2 "It's necessary your package have the ARCHIVE ${pink}desc${end} inside of directory '${dir_info}'."
		log_failure_msg2 "${pink}${info_desc}${end} have informations of your package."
		log_failure_msg2 "For more information use -h, --help."
		exit 1
	else
		source ${dir_info}/${info_desc}

		if [[ -z "$maintainer" ]]; then
			log_failure_msg2 "Check ${pink}${info_desc}${end}, sh_VARIABLE ${blue}maintainer${end} null"
			log_failure_msg2 "Enter the name of the package maintainer into variable maintainer."
			#exit 1
		elif [[ -z "$pkgname" ]]; then
			log_failure_msg2 "Check ${pink}${info_desc}${end}, VARIABLE ${blue}pkgname${end} null"
			log_failure_msg2 "Enter the name of the package into variable pkgname."
			#exit 1
		elif [[ -z "$version" ]]; then
			log_failure_msg2 "Check ${pink}${info_desc}${end}, VARIABLE ${blue}version${end} null"
			log_failure_msg2 "Enter a version of software into variable version."
			#exit 1
		elif [[ -z "$build" ]]; then
			log_failure_msg2 "Check ${pink}${info_desc}${end}, VARIABLE ${blue}build${end} null"
			log_failure_msg2 "Enter the build number of package."
			#exit 1
		elif [[ -z "$desc" ]]; then
			log_failure_msg2 "Check ${pink}${info_desc}${end}, VARIABLE ${blue}desc${end} null"
			log_failure_msg2 "Detail a small description into variable desc."
			#exit 1
		elif [[ -z "$url" ]]; then
			log_failure_msg2 "Check ${pink}${info_desc}${end}, VARIABLE ${blue}url${end} null"
			log_failure_msg2 "Enter a url of project/software into variable url."
			#exit 1
      fi
   fi

	for check_script in 'pre.sh' 'pos.sh' 'rm.sh'; do
		if [[ -e "${dir_info}/${check_script}" ]]; then
	   	if _GREP 'rm[[:space:]]+\-(rf|fr)' "${dir_info}/${check_script}" &>/dev/null; then
		   	log_failure_msg2 "${red}ERROR ${reset}${PWD}/${dir_info}/$check_script contain command rm -rf. ABORTED NOW."
   			return 1
      	fi
   	fi
   done
	sh_subshell_status
}

sh_create_pkg()
{
	local package=$1
	local ext_desc='desc'

	if tar --force-local --use-compress-program="zstd --ultra" --create --file ../"$package" .; then
		cp "$DESCME" ../"$package.$ext_desc" &>/dev/null
		pushd .. &>/dev/null
		if (( $CREATE_SHA256 )); then
			sha256sum "$package" > "$package".sha256
		fi
		if (( $GPG_SIGN )); then
			_GPG_SIGN "$package" || return 1
			popd &>/dev/null
		else
			return 0
		fi
	fi
	evaluate_retval
}

sh_generatepkg()
{
	local param=$@
	local inc=0

	if [[ ${#param} -eq 0 ]]; then # run standalone
		LAUTO=$true
		LLIST=$false
		pkg="${PWD##*/}.${PKG_EXT}"
	else
		for s in "${param[@]}"; do
			pkg="$s"
			continue
		done
	fi

	(( ncount++ ))
	if (( verbose >= 1 )); then
		log_msg "$(fmt) Generating info for package $pkg"
	fi

	if [[ ! -e "info/desc" ]]; then
		LFORCE=$true
	fi

	if (( LAUTO )) || (( LFORCE )); then
		if [[ -z "$DESC_PACKNAME" ]]; then
			sh_splitpkg "$pkg"
			field_pkgname="${aPKGSPLIT[$PKG_BASE]}"
			field_pkgver="${aPKGSPLIT[$PKG_VERSION]}"
			field_version="${aPKGSPLIT[$PKG_VERSION]}"
			field_pkgrel="${aPKGSPLIT[$PKG_BUILD]}"
			field_build="${aPKGSPLIT[$PKG_BUILD]}"
	    else
    		field_pkgname="${DESC_PACKNAME}"
    		field_pkgver="${DESC_VERSION}"
    		field_version="${DESC_VERSION}"
	    	field_pkgrel="${DESC_BUILD}"
	    	field_build="${DESC_BUILD}"
	   fi
	   [[ -z "$field_build" ]] && field_build="$DESC_BUILD"
		[[ -z "$DESC"        ]] && DESC="$field_pkgname-$field_version"
		_GENERATE_DESC "$field_pkgname" "$field_version" "$field_build" "${field_pkgver::-2}" "$field_pkgrel" || return $ERR_ERROR
	fi
	return $true
}

sh_createpkg()
{
   local param=$@
	local s
	local pkg=()

	for s in "${param[@]}"; do
      pkg="$s"
	done

	if [[ -z "$pkg" ]] ; then
		pkg=$(echo "$PWD" |sed 's/\// /g'|awk '{print $NF}')
	fi

	if (( verbose >= 1 )); then
		log_msg "$(fmt) Building package $pkg"
	fi

	pkg="$pkg.${PKG_EXT}"
	sh_generatepkg "$pkg"
   sh_name_format_pkg "$pkg" || exit 1
   sh_verify_on "$pkg" || exit 1
	sh_create_pkg "$pkg" || exit 1
	(( ncount++ ))
	if (( verbose >= 1 )); then
		log_msg "$(fmt) Generating package ${yellow}$pkg"
	fi
}

# -Sa
sh_alienpkg_main()
{
	sh_alienpkg_initvars $*
	sh_alienpkg_exec $*
}

sh_alienpkg_initvars()
{
	PKGS=$@
	BUILDDIR="${PKGCORE:=${CACHEDIR}/archives}"
	[[ -n ${BUILDDIR} ]] || BUILDDIR="${CACHEDIR}/archives" &> /dev/null
	[[ -d ${BUILDDIR} ]] || mkdir -p "${BUILDDIR}" &> /dev/null
}

sh_alienpkg_exec()
{
	local pkg=
	local param=$@
	local package
	local LFORCELOCAL=
	local string=
	local ntotalpkg=0
	local ntotalfindpkgs=0
	local ncount=0
	local arraypkg=
	local npackagesprocessed=0

	if [[ -z "${param}" ]]; then
		LALL=$true
	fi

  	for s in ${param[@]}; do
		string+="$s "
	done

	if (( LALL )); then
		if ! (( LTIME )); then
#			pkg=$(echo $ALIEN_CACHE_DIR/*.{zst,xz})
			pkg=$(find $ALIEN_CACHE_DIR/ -regextype posix-egrep -regex "$RE_ALIEN" -type f) ## mais rápido
		else
			pkg=$(find $ALIEN_CACHE_DIR/ -regextype posix-egrep -regex "$RE_ALIEN" -type f -mtime $mtime)
		fi
	else
  		for str in ${string[@]}; do
			if ! (( LTIME )); then
				pkg+="$(find $ALIEN_CACHE_DIR/ -iname "*$str*" -regextype posix-egrep -regex "$RE_ALIEN" -type f) "
			else
				pkg+="$(find $ALIEN_CACHE_DIR/ -iname "*$str*" -regextype posix-egrep -regex "$RE_ALIEN" -type f -mtime $mtime) "
			fi
		done
	fi

	arraypkg=($pkg)
	ntotalpkg=${#arraypkg[*]}
	ntotalfindpkgs=$ntotalpkg
	nfullpkg=${ntotalpkg}
	LFORCELOCAL=$LFORCE

	if (( $ntotalpkg )); then # package found?
		for package in $pkg
		do
			FULLDIR="$BUILDDIR/$package"
			ncount=0
			pkgtar=${package##*/}                #remove diretorio deixando somente nome do pacote
			pkgtar=${pkgtar%%.pkg.tar.zst}       #remove .ext
			pkgtar=${pkgtar%%.pkg.tar.xz}        #remove .ext
			cPacoteSemExt=${pkgtar%%.*}          # https://elmord.org/blog/?entry=20121227-manipulando-strings-bash
			cPacoteSemExt=${cPacoteSemExt%-*}    # https://elmord.org/blog/?entry=20121227-manipulando-strings-bash

			if ! (( LFORCELOCAL )); then
				local firstletter=${pkgtar::1}
				local FilteredPackage=$pkgtar.$PKG_EXT
				local destpkgGIT="${GITDIR}/packages/${firstletter}/${FilteredPackage}"
				local destpkgCORE="${GITDIR}/packages/core/${FilteredPackage}"

				if [[ -e ${destpkgGIT} || -e ${destpkgCORE} ]]; then
					if (( verbose >= 2 )); then
						log_failure_msg2 "$(fmt) ${orange}${FilteredPackage} ${reset}Package already exist in ${green}${GITDIR}/packages/${firstletter/}${reset} Use the -f option to force rebuild."
					fi
					(( ntotalpkg-- ))
					continue
				fi
			fi

			destdir="$BUILDDIR/$pkgtar"
			((ncount++))
			if (( verbose >= 1 )); then
				log_msg "$(fmt) Creating directory $destdir"
			fi
			mkdir -p "$destdir" 2>&-

			((ncount++))
			if (( verbose >= 1 )); then
				log_msg "$(fmt) Unpacking package $package at $destdir"
			fi
			tar --use-compress-program=zstd --force-local --extract --file "$package" -C "$destdir" >/dev/null 2>&1

			case $package in
				luit-[0-9]* ) sed -i -e "/D_XOPEN/s/5/6/" configure ;;
			esac

			sed -i 's/ = /="/g' "$destdir/.PKGINFO"  >/dev/null 2>&1
			sed -i 's/$/"/g' "$destdir/.PKGINFO"  >/dev/null 2>&1
			source "$destdir"/.PKGINFO

			export    ALIEN_DESC_BUILD="${pkgtar: -1}"
			export          DESC_BUILD="${pkgtar: -1}"
			export           ALIEN_URL="$url"
			export                 URL="$url"
			export       ALIEN_LICENSE="$license"
			export             LICENSE="$license"
			export          ALIEN_ARCH="$arch"
			export                ARCH="$arch"
			export          ALIEN_SIZE="$size"
			export                SIZE="$size"
			export          ALIEN_DESC="$pkgdesc"
			export                DESC="$pkgdesc"
			export           ALIEN_DEP="$depend"
			export                 DEP="$depend"
			export ALIEN_DESC_PACKNAME="$pkgname"
			export       DESC_PACKNAME="$pkgname"
			export 	ALIEN_DESC_VERSION="$pkgver"
			export        DESC_VERSION="$pkgver"
			export    ALIEN_DESC_BUILD="${pkgver: -1}"
			export          DESC_BUILD="${pkgver: -1}"
			export deps=$(grep ^depend "$destdir"/.PKGINFO | awk -F'"' '{print $2}')

			pushd "$destdir" >/dev/null 2>&1
			rm -f "$destdir"/.BUILDINFO "$destdir"/.MTREE "$destdir"/.PKGINFO   >/dev/null 2>&1

			((ncount++))
			sh_createpkg "${pkgtar}"

			if (( verbose >= 1 )); then
				echo
			fi
			(( ntotalpkg-- ))
			(( npackagesprocessed++ ))
		done

		if (( verbose >= 1 )); then
			log_msg "Total alien packages found     : $ntotalfindpkgs"
			log_msg "Total alien packages processed : $npackagesprocessed  ${green}Use the --force option to force rebuild."
		fi

		if ! (( LKEEP )); then
			((ncount++))
			if (( verbose >= 1 )); then
				log_msg "Verifying candidate packages files for pruning"
			fi
			#removeoldpkgchili $cPacoteSemExt
#			fetchpack -q -c "$GITDIR/packages/" -m /tmp/ "$cPacoteSemExt"
		fi
	else
		log_failure_msg "${red}error: ${orange}${x} ${reset}package target ${yellow}${param} ${reset}was ${red}NOT ${reset}found in ${yellow}${ALIEN_CACHE_DIR} ${reset}for import"
	fi
	unset size ncount ntotalpkg
	popd >/dev/null 2>&1
}

sh_alienpkg_pkgsize()
{
	size="$(du -sk --apparent-size)"
	size="$(( ${size%%[^0-9]*} * 1024 ))"
}

sh_alienpkg_logo()
{
	_CAT << 'EOF'
       _ _                  _
  __ _| (_) ___ _ __  _ __ | | ____ _
 / _` | | |/ _ \ '_ \| '_ \| |/ / _` |
| (_| | | |  __/ | | | |_) |   < (_| |
 \__,_|_|_|\___|_| |_| .__/|_|\_\__, |
                     |_|        |___/
EOF
	sh_version
}

sh_aliencheck()
{
	allfiles=$(ls -1 *.zst)

	for pkg in $allfiles
	do
		firstletter=${pkg::1}
		FilteredPackage=$(echo "$pkg" | sed 's/\(.*\)-/\1*/'|cut -d* -f1).chi.zst
		destpkg="${GITDIR}/packages/${firstletter}/${FilteredPackage}"
		if [[ -e "$destpkg" ]]; then
			echo "file exist: ${destpkg}"
		fi
	done
}

sh_upgrade()
{
	local param="$@"
	local LLIST=$false
	local count=0
	local s
	local item
	local cBaseInstalled cBaseVersionInstalled cVersionInstalled cBuildInstalled
	local	cBase cBaseVersion cVersion cBuild
	local ntotalinstalled
	local ntotalconfered
	local pkgrepo
	local ntotal_pkg_installed
	local ntotal_pkg_listed

	[[ $verbose -gt 1 ]] || (( verbose=0 ))
	LDEPS=$false
	LEXACT=$true
	LLIST=$false
	sh_listpkgdisp	"$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" "$param"

	local ntotal_pkg_installed=${public_ntotal_pkg_installed}
	local ntotal_pkg_listed=${public_ntotal_pkg_listed}

	for i in $public_pkg
	do
		sh_splitpkg "${i}"
		cBaseInstalled=${aPKGSPLIT[PKG_BASE]}
		cBaseVersionInstalled=${aPKGSPLIT[PKG_BASE_VERSION]}
		cVersionInstalled=${aPKGSPLIT[PKG_VERSION]}
		cBuildInstalled=${aPKGSPLIT[PKG_BUILD]}
		pkgrepo=$(grep ^"$cBaseInstalled$SEP $CACHEDIR_SEARCH/$PACKAGES_SPLIT" | cut -d$SEP -f4)
		count=0
		((ntotalconfered++))

		if [[ "${#pkgrepo}" -gt 0 ]]; then # pacote?
			for cPkg in ${pkgrepo}; do
				sh_splitpkg "${cPkg}"
				cBase=${aPKGSPLIT[PKG_BASE]}
				cBaseVersion=${aPKGSPLIT[PKG_BASE_VERSION]}
				cVersion=${aPKGSPLIT[PKG_VERSION]}
				cBuild=${aPKGSPLIT[PKG_BUILD]}

				case "$cBase" in
					Python) continue;;
					gtk+)   continue;;
				esac

				if [[ "$cBaseInstalled" == "$cBase" ]]; then
					((count++))
					if [[ "$(vercmp "$cBaseVersionInstalled" "$cBaseVersion")" -lt 0 ]]; then
						log_success_msg2 "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBase} ${reset}is being updated to newest version ($cVersion)."
						sh_doremove "$cBaseVersionInstalled" "OFF"
						sh_install "$cBase" -y -f --nodeps
					elif [[ "$cBaseVersionInstalled" = "$cBaseVersion" ]]; then
						if (( LFORCE )); then
							sh_install "$cBase" -y -f --nodeps
							continue
						else
							log_success_msg2 "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBase} ${reset}is already the newest version ${green}($cVersionInstalled)${reset}. Use the -f option to force reinstallation."
							continue
						fi
					else
						if (( LFORCE )); then
							sh_install "$cBase" -y -f --nodeps
						else
							log_success_msg2 "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBase} ${reset}is already the newest version ($cVersionInstalled)."
						fi
						if (( count > 1 )); then
							log_warning_msg "${orange}${cBaseInstalled} ${red}WARNING!! there is more than one release of the package in the repo!"
						fi
					fi
				else
   	 			log_warning_msg "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBase} ${reset}not installed."
				fi
			done
		else
			log_warning_msg "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBaseInstalled} ${red}WARNING!! package not in repo! Use 'fetch update' to update the database"
		fi
	done

	if [[ "${#public_pkg}" -le 1 ]]; then # nenhum pacote?
		log_warning_msg "${orange}${@}${cyan} package not installed"
		echo
		conf "${blue}:: ${reset}Install Pakages(s)?"
		LAUTO=$?
		if (( LAUTO )); then
			sh_install "$param" -y -f --nodeps
		fi
	fi
	sh_cdroot
}

checkDependencies()
{
   local errorFound=0
   declare -a missing

   for d in "${DEPENDENCIES[@]}"; do
      [[ -z $(command -v "$d") ]] && missing+=("$d") && errorFound=1 && printf "ERRO: não encontrei o comando '$d'\n"
   done
   #[[ ${#missing[@]} -ne 0 ]]
   if (( errorFound )); then
    echo "---IMPOSSÍVEL CONTINUAR---"
    echo "Esse script precisa dos comandos listados acima" >&2
    echo "Instale-os e/ou verifique se estão no seu \$PATH" >&2
    exit 1
  fi
}

sh_cleaning()
{
	log_msg "${pink}Cleaning temporary files${reset}"
	rm -rf "${TMP_DIR_ROOT:?}"/ &> /dev/null
}

cleanup()
{
 	echo "** Trapped CTRL-C"
	log_msg "${pink}Cleaning...${reset}"
	cp -f "$TMP_DIR_BACKUP"/* "$CACHEDIR_SEARCH"/ &> /dev/null
	rm -rf "${TMP_ROOT_BACKUP:?}"/ &> /dev/null
	rm -f /tmp/ARRAYPKGFULL
	kill -TERM -$$
	exit
}
#trap "" 2 			# disable Ctlr+C
#trap    2  	 		# enable Ctlr+C
set -m
trap - INT
trap 'cleanup' 2 	# SIGINT SIGTERM SIGTSTP

sh_backup()
{
	if (( verbose >= 2 )); then
		log_msg "${pink}Making backup: $CACHEDIR_SEARCH/${reset}"
	fi
	mkdir -p "$TMP_DIR_BACKUP"/ &> /dev/null
	mkdir -p "$TMP_DIR_FOLDERS"/ &> /dev/null
	cp -f "$CACHEDIR_SEARCH"/* "$TMP_DIR_BACKUP"/ &> /dev/null
}

#figlet
logo()
{
	_CAT << 'EOF'
  __      _       _
 / _| ___| |_ ___| |__     Copyright (c) 2019-2022 Vilmar Catafesta <vcatafesta@gmail.com>
| |_ / _ \ __/ __| '_ \    Copyright (c) 2019-2022 Chili GNU/Linux Development Team <root@chililinux.com>
|  _|  __/ || (__| | | |
|_|  \___|\__\___|_| |_|   Este programa pode ser redistribuído livremente
                           sob os termos da Licença Pública Geral GNU.
EOF
	sh_version
}

usage()
{
	cat <<EOF
${cyan}Most used commands:
${red}  -h,  help           ${reset}- display this help and exit
${red}  -Sy, update         ${reset}- update list packages in the repository online. Need Internet
${red}  -S,  install        ${reset}- install packages
${red}  -Ss, search         ${reset}- search for packages
${red}  -Su, upgrade        ${reset}- upgrade packages
${red}  -Sw, download       ${reset}- only download the binary package into cache directory
${red}  -Sr, recreate       ${reset}- recreate database installed packages
${red}  -Sa, alienpkg       ${reset}- import package from ArchLinux
${red}  -Sg, generate       ${reset}- generate info package from source
${red}  -C,  create         ${reset}- build package
${red}  -Sl, local          ${reset}- install local package
${red}  -Sc, clean          ${reset}- erase downloaded packages files
${red}  -Sm, meta           ${reset}- install meta packages
${red}  -R,  remove         ${reset}- remove packages
${red}  -La, list-avaiable  ${reset}- list avaiable packages based on package names
${red}  -Lc, list-cache     ${reset}- list downloaded packages in cache
${red}  -Li, list-installed ${reset}- list installed packages
${red}  -Po, out-cache      ${reset}- list packages out-cache
${red}  -Qi, show           ${reset}- show package details
${red}  -Qq, total          ${reset}- total packages installed
${red}  -V,  version        ${reset}- output version information and exit
${cyan}ex:
  ${reset}fetch ${pink}-Sy ${reset} self ${yellow}=> Update self fetch via internet
  ${reset}fetch ${pink}-Sy ${reset}      ${yellow}=> Update database
  ${reset}fetch ${pink}-Syy${reset}      ${yellow}=> Force update database
  ${reset}fetch ${pink}-S  ${reset}<package> [<...>] [--all] [--noconfirm] [--force] [--nodeps]
  ${reset}fetch ${pink}-R  ${reset}<package> [<...>] [--all] [--noconfirm] [--force]
  ${reset}fetch ${pink}-Su ${reset}[<package>] [<...>] [--all] [--nonconfirm] [--force]
  ${reset}fetch ${pink}-Ss ${reset}<package> [<...>] [--noconfirm] [--force] [--exact] [--nodeps]
  ${reset}fetch ${pink}-Li ${reset}[<package>] [<...>] [--all] [--exact]
  ${reset}fetch ${pink}-Sw ${reset}[<package>] [<...>] [--all] [--noconfirm] [--force]
  ${reset}fetch ${pink}-Qi ${reset}[<package> [<...>]]
  ${reset}fetch ${pink}-C  ${reset}[<packname-version-build>]
  ${reset}fetch ${pink}-Sm ${reset}<xorg> [--noconfirm] [--force]
  ${reset}fetch ${pink}-Sa ${reset}<package> [<...>] [--all] [--noconfirm] [--force] [--mtime=<n>] [--keep] [--default]
EOF
}

sh_parseparam()
{
	local param="$*"
   local s
   local newparam

	LDEPS=$true
	LAUTO=$false
	LFORCE=$false
	verbose=1
	mtime=0
	SPLITPOS='4'
	LLIST=$false
	LEXACT=$false
	LALL=$false
	LSELF=$false
	LKEEP=$false
	LTIME=$false
	LSEARCHONLY=$true
	LSKIPERROR=$false

	for s in ${param[@]}
   do
      [[ $(tolower "${s:0:8}") = "--mtime=" ]] && { LTIME=$true; mtime="${s:8}"; continue;}
      [[ $(tolower "${s}") = "--default"    ]] && { LTIME=$true; LKEEP=$true; LALL=$true; continue; }
      [[ $(tolower "${s}") = "--keep"       ]] && { LKEEP=$true; continue; }
      [[ $(tolower "${s}") = "self"         ]] && { LSELF=$true; continue; }
      [[ $(tolower "${s}") = "--self"       ]] && { LSELF=$true; continue; }
      [[ $(tolower "${s}") = "--nodeps"     ]] && { LDEPS=$false; continue; }
      [[ $(tolower "${s}") = "-y"           ]] && { LAUTO=$true; continue; }
      [[ $(tolower "${s}") = "--auto"       ]] && { LAUTO=$true; continue; }
      [[ $(tolower "${s}") = "--noconfirm"  ]] && { LAUTO=$true; continue; }
      [[ $(tolower "${s}") = "-f"           ]] && { LFORCE=$true; continue; }
      [[ $(tolower "${s}") = "--force"      ]] && { LFORCE=$true; continue; }
      [[ $(tolower "${s}") = "--noverbose"  ]] && { verbose=0; continue; }
      [[ $(tolower "${s}") = "--verbose"    ]] && { verbose=2; continue; }
      [[ $(tolower "${s}") = "--v"          ]] && { verbose=1; continue; }
      [[ $(tolower "${s}") = "--vv"         ]] && { verbose=2; continue; }
      [[	$(tolower "${s}") = "--vvv"        ]] && { verbose=3; continue; }
      [[ $(tolower "${s}") = "-v"           ]] && { verbose=1; continue; }
      [[ $(tolower "${s}") = "-vv"          ]] && { verbose=2; continue; }
      [[	$(tolower "${s}") = "-vvv"         ]] && { verbose=3; continue; }
      [[	$(tolower "${s}") = "-q"           ]] && { verbose=0; continue; }
      [[ $(tolower "${s}") = "--quiet"      ]] && { verbose=0; continue; }
      [[ $(tolower "${s}") = "off"          ]] && { LLIST=$false; continue; }
      [[ $(tolower "${s}") = "on"           ]] && { LLIST=$true; continue; }
      [[ $(tolower "${s}") = "--exact"      ]] && { LEXACT=$true; continue; }
      [[ $(tolower "${s}") = "all"          ]] && { LALL=$true; continue; }
      [[ $(tolower "${s}") = "--all"        ]] && { LALL=$true; continue; }
      [[ $(tolower "${s}") = "--skiperror"  ]] && { LSKIPERROR=$true; continue; }
      [[ $(tolower "${s}") = "--nocolor"    ]] && { unsetvarcolors; continue;}
#		newparam="$newparam $(echo ${s})"
		newparam+="$s"
   done
#  debug "$newparam"
	log_prefix
	init "$newparam"
}

init()
{
  	while test $# -gt 0
	do
		case "${1}" in
			-Si|-S|install)								shift;LSEARCHONLY=$false;sh_install "$@";return;;
			-Sl|local)  									shift;sh_initinstallpkg "$@";exit;;
			-Sa|alienpkg)	  		   					shift;sh_alienpkg_main "$@";return;;
			-Sc|clean)  									sh_clean "$@";exit;;
			-Sg|-g|generate)							   shift;sh_generatepkg "$@";exit;;
			-Ss|search)	     								shift;sh_search "$@";exit;;
			-Sy|update)										shift;sh_updaterepo "${param}";exit;;
			-Syy|refresh)									shift;sh_update "${param}";exit;;
			-c|-C|create)					   			shift;sh_createpkg "${@}";exit;;
			-Sm|--meta|meta) 		            		shift;sh_installmeta "${@}";exit;;
			-R|remove) 										shift;sh_remove "$@";exit;;
			-Sw|download) 									shift;sh_download "$@";exit;;
			-Sr|recreate)									shift;sh_recreatefilepackagesinstalled;exit;;
			-Qq|total)									   shift;sh_totalpackagesinstalled;exit;;
			-L|list)    	 								shift;sh_list "$@";exit;;
			-La|avaiable) 									shift;sh_list "$@";exit;;
			-Lc|list-cache) 	        					shift;sh_FilesInCache "${param}";exit;;
			-Li|list-installed)							shift;sh_listinstalled "${@}";exit;;
			-Po|out-cache)	            				shift;sh_pkgoutcache "${param}";exit;;
			-Qi|show) 										shift;sh_show "$@";exit;;
			-Su|upgrade)									shift;sh_upgrade "$@";exit;;
      	-V*|--version|version)						logo;exit 0;;
      	-f*|--force)									LFORCE=1;;
      	-y*|--auto)										LAUTO=1;;
      	-exact|--exact)								LEXACT=1;;
      	-q|--quiet)										verbose=0;;
      	--nocolor)										unsetvarcolors;;
      	-v*|--no-verbose|--verbose)				(( ++verbose ));test "${1:0:5}" = "--no-" && verbose=0;;
      	-h|--help)										usage;exit $(( $# ? 0 : 1 ));;
#      	*)													usage;exit 0;_last_positional="$1";_positionals+=("$_last_positional");_positionals_count=$((_positionals_count + 1));;
      	*)													die "operation not supported: $1 (use -h for help)";;
		esac
		shift
	done
}

parsestdin()
{
	file=${1--} # POSIX-compliant; ${1:--} can be used either.
	IFS=$'\n'
	while read -r line; do
		echo "$line"
		init -a "$line"
	done < /dev/stdin
	#done < <(cat -- "$file")
	#done < <(cat /dev/stdin)
	#done < /dev/stdin
	#done < <(cat "$@")
}

configure
checkDependencies

if [[ -z "${1-}" ]]; then
	die "no operation specified (use -h for help)"
fi

if [[ -z $1 || $1 = @(-h|--help) || $1 = "-h" || $1 = "--help" || $1 = "help" || $1 = "-help" ]]; then
	usage
	exit $(( $# ? 0 : 1 ))
fi

if [[ -z $1 || $1 = @(-v|--version) || $1 = "-v" || $1 = "--version" || $1 = "version" || $1 = "-version" ]]; then
	logo
	exit $(( $# ? 0 : 1 ))
fi

sh_checkroot "$@"
sh_checkdir
#sh_arraypkgfull
#sh_checkparametros "$@"
#init "$@"

if [ -p /dev/stdin ]; then
	#for FILE in "$@" /dev/stdin
	for FILE in /dev/stdin
	do
		while IFS= read -r LINE
		do
			#echo "$LINE"
			init "$@" "$LINE"
		done < "$FILE"
	done
else
	# init "$@"
	sh_parseparam "$@"
fi

# vim:set ts=3 sw=3 et:

#converter .desc para pacotes instalado
#for i in *.desc; do echo $i; var=(${i/%-any.chi.zst.desc/.desc}); cp $i $var;done
# '["]listaDezenas["]:\s*[[]\s+["]\K([0-9]{2})(["],?\s+["])((?1))+(?2)+((?1))+(?2)+((?1))+(?2)+((?1))+(?2)+((?1))'
# wget https://servicebus2.caixa.gov.br/portaldeloterias/api/megasena/ --no-check-certificate -qO - | jq -r '.numero'
# jq -r '.listaDezenas[1]' temp
# grep -Po '"descricaoFaixa":.*?[^\\]",' temp
# cat temp | python -c "import json,sys;obj=json.load(sys.stdin);print(obj['listaDezenas']);"
