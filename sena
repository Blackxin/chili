#!/usr/bin/env bash
#  sena - aplicativo para gerar numeros aleatorios da sena
#
#  Created: 2022/02/15
#  Altered: 2022/07/08
#
#  Copyright (c) 2022-2022, Benedito Ramos <diramos@uol.com.br>
#  Copyright (c) 2022-2022, Vilmar Catafesta <vcatafesta@gmail.com>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

#  sena uses quite a few external programs during its execution. You
#  need to have at least the following installed for makepkg to function:
#     awk, bsdtar (libarchive), bzip2, coreutils, fakeroot, file, find (findutils),
#     gettext, gpg, grep, gzip, sed, tput (ncurses), xz, etc
#########################################################################
#global
CPATH=$PWD
filejogos="$CPATH/jogos.txt"
filejogosformatado="$CPATH/jogosformatado.txt"
fileresult="$CPATH/resultadosena.txt"
fileUltSorteio='/tmp/UltSorteio.txt'
fileUltSorteioAtualizado='/tmp/UltSorteioAtualizado.txt'
SITE='https://servicebus2.caixa.gov.br/portaldeloterias/api/megasena/'
_VERSION_='1.50.20220708'
DEPENDENCIES=(curl wget grep printf mktemp sort sed awk tail cat tput)
true=1
false=0
IFS=$' \t\n'
SAVEIFS=$IFS

sh_playsena()
{
	declare -i qtdjogos=$1
   [[ $# -gt 2 ]] && die "erro: parâmetros em excesso. (use -h for help)"
   [[ $# -eq 2 ]] && declare -i qtddezenas=$2 || declare -i qtddezenas=6
 	[[ qtdjogos   -lt 1  ]] && die "erro: mínimo de 1 jogo brother! (use -h for help)"
 	[[ qtddezenas -gt 15 ]] && die "erro: máximo de dezenas jogadas é: 15. (use -h for help)"
 	[[ qtddezenas -lt  6 ]] && die "erro: mínimo de dezenas jogadas é: 6. (use -h for help)"
 	[[ qtddezenas -gt 15 ]] && qtddezenas=15
 	[[ qtddezenas -lt  6 ]] && qtddezenas=6

  	LCONF=1
	if [[ -e $filejogos ]]; then
		conf "${red}:: ${reset}Existe um arquivo de jogos, deseja substitui-lo?"
   	LCONF=$?
	   if !(( $LCONF )); then
			msg "Detalhes do arquivo de jogos feito"
			stat $filejogos
			msg "Exibindo os ultimos jogos feitos"
			cat $filejogos
			exit
	   fi
   fi

	[[ ! -e $fileresult ]] && >| $fileresult
	bytes=$(filesize $fileresult); [[ $bytes -eq 0 ]] && die "erro: necessário atualizar o BD. (use -h for help)" || sh_resultadosena
	declare -i resto=$(( qtddezenas % 2 ))
	declare -i metadeqtddezenas=$(( qtddezenas / 2 ))
	declare -i outrametade=$metadeqtddezenas
	declare -i n=0
	declare -i njogosregistrados=0

   if (( $LCONF )); then
		>| $filejogos
	else
		njogosregistrados=$(sh_linecount $filejogosformatado)
	fi

 	if [[ resto -gt 0 ]] ; then
		((metadeqtddezenas++))
	fi

	while [[ n -lt qtdjogos ]]; do
	  	jogos1a30=$(shuf  -i  1-30 -n $metadeqtddezenas | tr -d ',e' | tr -s ' ' | sed 's/ / \n/g' | sort -n | while read a; do printf '%02d ' $a ; done)
	  	jogos31a60=$(shuf -i 31-60 -n $outrametade      | tr -d ',e' | tr -s ' ' | sed 's/ / \n/g' | sort -n | while read a; do printf '%02d ' $a ; done)
	  	#echo $jogos1a30 $jogos31a60 # 09 11 14 35 37 50
	   line="$jogos1a30$jogos31a60"

  	 	if [[ qtddezenas -eq 6 ]] ; then
			if grep -q -o "$line" $fileresult; then  # jogo existe no BD? descarta!
	  			printf "Jogo ${red}#%04d${reset} ${orange}%02d${reset} dezenas geradas: $pink%s${red}-> foi descartado, já existe no BD!${reset}\n" "$n" $qtddezenas "$line"
				continue
			fi
		fi

		if grep -q -o "$line" $filejogos; then  # jogo existe? descarta!
  			printf "Jogo ${red}#%04d${reset} ${orange}%02d${reset} dezenas geradas: $pink%s${red}-> foi descartado, já existe no jogo atual!${reset}\n" "$n" $qtddezenas "$line"
			continue
		fi

		((n++))
		((njogosregistrados++))
		printf "Jogo ${red}#%04d${reset} ${orange}%02d${reset} dezenas geradas: $pink%s${green}-> foi aceito${reset}\n" "$n" $qtddezenas "$line"
		echo $line >> $filejogos
		[[ $njogosregistrados -lt 10 ]] && var="Jogo "0"$njogosregistrados: " || var="Jogo $njogosregistrados: "
		echo "$(date +"%d/%m/%Y %T") $var $line" >> $filejogosformatado
	done
	filetmp=$(mktemp)
	sort $filejogos > $filetmp; cp $filetmp $filejogos; rm $filetmp 2> /dev/null
	#chown www-data $filejogos
	#chgrp www-data $filejogos
}

sh_linecount()
{
   awk 'END {print NR}' $1
}

die()
{
   local msg=$1; shift
   printf "${red}$msg${reset}\n" >&2
   exit 1
}

msg()
{
   local msg=$1; shift
   printf "${green}$msg${reset}\n" >&2
   return
}

erro()
{
   local msg=$1; shift
   printf "${red}$msg${reset}\n" >&2
   return
}

sh_checknet()
{
   # have internet?
   msg "${green}Testing internet from ${SITE}"
 	curl --insecure $SITE >/dev/null 2>&1 ||
   {
      retorno=$?
	   msg "No route to server ($SITE) - Rodando com BD velho mesmo"
   }
   retorno=$?
	return $retorno
}

setvarcolors(){
   if tput setaf 1 &> /dev/null; then
      tput sgr0; # reset colors
      bold=$(tput bold);
      reset=$(tput sgr0);
      rst=$(tput sgr0);
      rs=$(tput sgr0);
      blue=$(tput setaf 33);
      cyan=$(tput setaf 37);
      green=$(tput setaf 2);
      orange=$(tput setaf 166);
      purple=$(tput setaf 125);
      red=$(tput setaf 124);
      violet=$(tput setaf 61);
      white=$(tput setaf 15);
      yellow=$(tput setaf 136);
      pink=$(tput setaf 129);
      black=$(tput setaf 0);
   else
      bold='';
      reset="\e[0m";
      rst="\e[0m";
      rs="\e[0m";
      reset="\e[0m";
      blue="\e[1;34m";
      cyan="\e[1;36m";
      green="\e[1;32m";
      orange="\e[1;33m";
      purple="\e[1;35m";
      red="\e[1;31m";
      violet="\e[1;35m";
      white="\e[1;37m";
      yellow="\e[1;33m";
      pink="\033[35;1m";
      black="\e[1;30m";
   fi
}

check_deps()
{
   local errorFound=0
   declare -a missing

   for d in "${DEPENDENCIES[@]}"; do
      [[ -z $(command -v $d) ]] && missing+=($d) && errorFound=1 && printf "${red}ERRO${reset}: não encontrei o comando ${orange}'$d'${reset}\n"
   done
   #[[ ${#missing[@]} -ne 0 ]]
   if (( $errorFound )); then
   	erro "#### IMPOSSÍVEL CONTINUAR ####"
    	msg "Esse script precisa dos comandos listados acima" >&2
    	msg "Instale-os e/ou verifique se estão no seu \$PATH" >&2
    	exit 1
	fi
}

filesize()
{
	local bytes=$(stat -c %s $1)
	echo $bytes
}

conf()
{
   read -p "$1 [S/n]"
   [[ ${REPLY^} == "" ]] && return $true
   [[ ${REPLY^} == "S" ]] && return $true
   [[ ${REPLY^} == N ]] && return $false
   die "erro: resposta deve ser S ou N"
}

sh_compare()
{
	[[ ! -e $filejogos ]] && { erro "erro: nenhum jogo realizado ainda para comparação. (use -h for help)"; exit 1;}
	nsize=$(filesize $filejogos)
	[[ $nsize -eq 0    ]] && { erro "erro: nenhum jogo realizado ainda para comparação. (use -h for help)"; exit 1;}

:<<'comment'
	while read -r i; do
		if grep -q -o "$i" $fileresult; then
			echo "$i - ${red}FALHA ↓ Já existe no BD"${reset}
		else
			echo "$i - ${green}OK ↑ não encontrado no BD"${reset}
		fi
	done < $filejogos
comment

	IFS=$'\n'
	local re='[0-9]{2}[ ]?'
	local aResult=($(awk -F'-' '{ print $3 }' $fileresult))
	#local aJogos=($(awk -F "$re" 'lista[$1]++' $filejogos))
	local aJogos=($(awk '{print " "$0}' $filejogos))
	local n=1
	local value

:<<'comment'
	info "${aJogos[*]}"
	echo
	echo "${aJogos[0]}"
	echo "${aJogos[1]}"
comment

	for value in ${aJogos[*]}
	do
	   #info "$value"
	   if [[ ! "${aResult[*]}" =~ "${value}" ]]; then
	      printf "Jogo (${pink}$n${rs}) $value - ${green}OK ↑ não encontrado no BD${reset}\n"
	   else
	      printf "Jogo (${pink}$n${rs}) $value - ${red}FALHA ↓ Já existe no BD${reset}\n"
	   fi
	   ((n++))
	done
	IFS=$SAVEIFS
}

sh_atualizaBD()
{
	contLinha=$1
	wget $SITE$contLinha --no-check-certificate -qO- > $fileUltSorteioAtualizado
	listaDezenas=$(sed -n '/listaDezenas/,/],/p' $fileUltSorteioAtualizado | sed 's/[^0-9]//g' | sed -e "s/\r//g" | awk -F"-" '{print $1}')
	listaDezenas=$(echo $listaDezenas | cut -c1-18)
	dataApuracao=$(grep '"dataApuracao":' $fileUltSorteioAtualizado | awk '{print $2}' | sed 's/\"//g' | sed 's/\,//g' | sed -e "s/\r//g" )
	valorEstimadoProximoConcurso=$(grep '"valorEstimadoProximoConcurso":' $fileUltSorteioAtualizado | awk -F"-" '{print $2}' | sed 's/\,//g')
	dadosSena=$(sed -n '/"faixa": 1/,/},/p' $fileUltSorteioAtualizado)
	dadosQuina=$(sed -n '/"faixa": 2/,/},/p' $fileUltSorteioAtualizado)
	dadosQuadra=$(sed -n '/"faixa": 3/,/},/p' $fileUltSorteioAtualizado)
	numGanhadoresSena=$(echo $dadosSena | awk -F'"' '{ print $5 }' | sed 's/://g' | sed 's/,//g')
	valorPremioSena=$(echo $dadosSena | awk -F'"' '{print $7}' | sed 's/://g' | sed 's/,//g')
	valorPremioSena=$(awk '{printf "%.2f\n" ,$1}' <<< "$valorPremioSena")
	valorPremioSenaFormat=$(echo $valorPremioSena  | sed -e :a -e 's/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta' | tr ',.' '.,')
  	varLinhaInteira=$(echo $contLinha - $dataApuracao - $listaDezenas - $valorPremioSenaFormat - $numGanhadoresSena)
  	echo $varLinhaInteira |& tee -a $fileresult
}

sh_checkresultadosfaltantes()
{
	local -i numUltSorteioGravado=$1
	local -i n=0
	local value
	local array

	msg "Checando a integridade do BD. Aguarde..."
	local array=($(awk '{ print $1 }' $fileresult))

	for value in $(seq $numUltSorteioGravado)
	do
   	if [[ ! " ${array[*]} " =~ " ${value} " ]]; then
			if !(( $n )); then
				msg "Atualizando Banco de Dados. Aguarde..."
			fi
			((n++))
			sh_atualizaBD "$value"
	   fi
	done
}

sh_resultadosena()
{
	#### REMOVENDO ARQUIVOS TEMPORARIOS
	rm $fileUltSorteio 2> /dev/null
	rm $fileUltSorteioAtualizado 2> /dev/null

	sh_checknet; [[ $? = 0 ]] || return 1
	[[ ! -e $fileresult ]] && >| $fileresult

	#### COLETANDO DADOS DO ULTIMO RESULTADO DA MEGASENA PULICADO PELA API DA CAIXA
	wget $SITE --no-check-certificate -qO- > $fileUltSorteio
	declare -i numUltSorteio=$(awk '/["]numero["]:/ {print $2}' $fileUltSorteio | sed 's/\,//g' | sed '/^$/d' | sed -e "s/\r//g")

	#### COLETANDO O NUMERO DO ULTIMO SORTEIO GRAVADO NO BD
	declare -i numUltSorteioGravado=$(awk 'END {print NR}' $fileresult)

	#### COLETANDO DADOS DOS DOS RESULTADOS NAO INCLUÍDOS NO BD
	declare -i falta=$(( numUltSorteio - numUltSorteioGravado ))
	printf "Sorteios feitos pela CAIXA : ${red}$numUltSorteio${reset}\n"
	printf "Sorteios registrados no BD : ${orange}$numUltSorteioGravado${reset}\n"
	msg "${falta} novo(s) registro(s) encontrado(s)!"
	sh_checkresultadosfaltantes $numUltSorteio
	sort -g -u $fileresult > $fileresult.sort
	cp $fileresult.sort $fileresult
	rm -f $fileresult.sort
	msg "OK. Banco de Dados atualizado!"

	#### REMOVENDO ARQUIVOS TEMPORARIOS
	rm $fileUltSorteio 2> /dev/null
	rm $fileUltSorteioAtualizado 2> /dev/null
}

sh_version()
{
   printf "${orange}${0##*/} v${_VERSION_}\n"
}

sh_logo()
{
   cat << 'EOF'
   ________  ____  ____ _
  / ___/ _ \/ __ \/ __ `/
 (__  )  __/ / / / /_/ /
/____/\___/_/ /_/\__,_/
EOF
	sh_version
}

sh_val()
{
	if [[ ${1} =~ ^([0-9]+)$ ]];then
		echo "N"
	elif [[ ${1} =~ ^([[:alpha:]]+)$ ]];then
		echo "C"
	else
		echo "U"
	fi
}

sh_listarjogos()
{
	[[ ! -e $filejogosformatado ]] && die "erro: arquivo log de jogos ainda não existe. Faça alguns jogos primeiro. (use -h for help)"
	more $filejogosformatado
}

sh_usage()
{
	cat <<EOF
${white}sena v$_VERSION_${reset}
${orange}uso:${reset}
   sena ${pink}-j 3${cyan}                # jogar 03 jogos (padrão 6 dezenas)${reset}
   sena ${pink}-j 10${cyan}               # jogar 10 jogos (padrão 6 dezenas)${reset}
   sena ${pink}-j 10 6${cyan}             # jogar 10 jogos com 06 (min) dezenas${reset}
   sena ${pink}-j 5 15${cyan}             # jogar 05 jogos com 15 (max) dezenas${reset}
   sena ${pink}-h|--help${cyan}           # este help${reset}
   sena ${pink}-c|--compare${cyan}        # comparar jogos${reset}
   sena ${pink}-l|--log${cyan}            # list log de jogos${reset}
   sena ${pink}-U|--update${cyan}         # atualizar BD${reset}
   sena ${pink}-V|--version${cyan}        # mostra versão atual${reset}
EOF
}

init()
{
   while test $# -gt 0
   do
      case "${1}" in
		   -h|--help) sh_usage; exit $(( $# ? 0 : 1 ));;
   		-c|--compare) sh_compare; exit $(( $# ? 0 : 1 ));;
   		-l|--log) sh_listarjogos; exit $(( $# ? 0 : 1 ));;
   		-U|--update) sh_resultadosena; exit $(( $# ? 0 : 1 ));;
   		-V|--version) sh_logo; exit $(( $# ? 0 : 1 ));;
   		-j|--jogo)
				shift;
   			[[ $# -lt 1 ]] && die "erro: requer argumento/parâmetro. (use -h for help)";
				ctype1=$(sh_val $1);	[[ $ctype1 != "N" ]] && die "erro: primeiro parâmetro deve ser numérico. (use -h for help)";
   			if test $# -eq 2; then
   				ctype2=$(sh_val $2);	[[ $ctype2 != "N" ]] && die "erro: segundo parâmetro deve ser numérico. (use -h for help)";
	  			fi
 				sh_playsena "$@"
 				exit $(( $# ? 0 : 1 ))
 				;;
         *)  die "operação não suportada: $1 (use -h for help)";;
      esac
      shift
   done
}

setvarcolors
check_deps
[[ -z $1 ]] && { sh_usage; exit $(( $# ? 0 : 1 ));}
init $@
