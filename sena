#!/usr/bin/env bash
#  sena - aplicativo para gerar numeros aleatorios da sena
#
#  Created: 2022/02/15
#  Altered: 2022/07/10
#
#  Copyright (c) 2022-2022, Benedito Ramos <diramos@uol.com.br>
#  Copyright (c) 2022-2022, Vilmar Catafesta <vcatafesta@gmail.com>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

#  sena uses quite a few external programs during its execution. You
#  need to have at least the following installed for makepkg to function:
#     awk, bsdtar (libarchive), bzip2, coreutils, fakeroot, file, find (findutils),
#     gettext, gpg, grep, gzip, sed, tput (ncurses), xz, etc
#########################################################################
#global

#system
_VERSION_='2.1.20220710'
DEPENDENCIES=(curl wget grep printf mktemp sort sed awk tail cat tput stat dialog find)

#paths/files/urls
#CPATH=/opt/sena
CPATH=$PWD
filejogos="$CPATH/jogos.txt"
filejogosformatado="$CPATH/jogosformatado.txt"
fileresult="$CPATH/resultadosena.txt"
fileUltSorteio='/tmp/UltSorteio.txt'
fileUltSorteioAtualizado='/tmp/UltSorteioAtualizado.txt'
SITE='https://servicebus2.caixa.gov.br/portaldeloterias/api/megasena/'

#conf adicionais
IFS=$' \t\n'
SAVEIFS=$IFS
sep='\xe2\x94\x82'

# flag boolean
true=1
false=0

# flag dialog exit status codes
: "${D_OK=0}"
: "${D_CANCEL=1}"
: "${D_HELP=2}"
: "${D_EXTRA=3}"
: "${D_ITEM_HELP=4}"
: "${D_ESC=255}"

[ -e /chili/core.sh ] && source /chili/core.sh

sh_playsena()
{
	local filelog
	local cnow
   declare -i qtddezenas
	declare -i qtdjogos=$1

   [[ $# -gt 2 ]] && die "ERRO: parâmetros em excesso. (use -h for help)"
   [[ $# -eq 2 ]] && qtddezenas=$2 || qtddezenas=6
 	[[ qtdjogos   -lt 1  ]] && die "ERRO: mínimo de 1 jogo brother! (use -h for help)"
 	[[ qtddezenas -gt 15 ]] && die "ERRO: máximo de dezenas jogadas é: 15. (use -h for help)"
 	[[ qtddezenas -lt  6 ]] && die "ERRO: mínimo de dezenas jogadas é: 6. (use -h for help)"
 	[[ qtddezenas -gt 15 ]] && qtddezenas=15
 	[[ qtddezenas -lt  6 ]] && qtddezenas=6

  	LCONF=1
	if [[ -e $filejogos ]]; then
		cfiledatahora=$(sh_filedatetime "$filejogos")
		njogos=$(sh_linecount "$filejogos")
		sh_conf "${red}:: ${reset}Existe arquivo de jogos gerado em: ${yellow}$cfiledatahora${reset} com ${bold}${red}($njogos)${reset} palpites. Deseja substitui-lo?"
   	LCONF=$?
	   if ! (( LCONF )); then
			msg "1 - Detalhes do arquivo de palpites"
			echo -n "$bold$cyan"; stat "$filejogos"; echo -n "$reset"
			msg "2 - Exibindo os ultimos palpites feito"
			echo -n "$yellow"; cat "$filejogos"; echo -n "$reset"
			exit
	   fi
   fi

	[[ ! -e "$fileresult" ]] && :>| "$fileresult"
	[[ $(sh_filesize "$fileresult") -eq 0 ]] && die "ERRO: necessário atualizar o BD. (use -h for help)"
	sh_update

	declare -i resto=$(( qtddezenas % 2 ))
	declare -i metadeqtddezenas=$(( qtddezenas / 2 ))
	declare -i outrametade="$metadeqtddezenas"
	declare -i n=0
	declare -i njogosregistrados=0
	filelog=$(date +"%d%m%Y-%T" | sed 's/://g').log

   if (( LCONF )); then
		:>| "$filejogos"
	else
		njogosregistrados=$(sh_linecount "$filejogosformatado")
	fi
	:>| "$filelog"

 	if [[ resto -gt 0 ]] ; then
		((metadeqtddezenas++))
	fi

	while [[ n -lt qtdjogos ]]; do
	  	jogos1a30=$(shuf  -i  1-30 -n "$metadeqtddezenas" | tr -d ',e' | tr -s ' ' | sed 's/ / \n/g' | sort -n | while read -r a; do printf '%02d ' "$a" ; done)
	  	jogos31a60=$(shuf -i 31-60 -n "$outrametade"      | tr -d ',e' | tr -s ' ' | sed 's/ / \n/g' | sort -n | while read -r a; do printf '%02d ' "$a" ; done)
	  	#echo $jogos1a30 $jogos31a60 # 09 11 14 35 37 50
	   line="$jogos1a30$jogos31a60"
		cnow=$(sh_datetime)
		((njogosregistrados++))
		[[ njogosregistrados -lt 10 ]] && var="Jogo 0$njogosregistrados: " || var="Jogo $njogosregistrados: "

  	 	if [[ qtddezenas -eq 6 ]] ; then
			if grep -q -o "$line" "$fileresult"; then  # jogo existe no BD? descarta!
	  			printf "Jogo ${bold}${cyan}#%04d ${yellow}%02d${reset} dezenas geradas: $pink%s${red}-> foi descartado, já existe no BD!${reset}\n" "$n" "$qtddezenas" "$line"
				echo "$cnow $var $line -> foi descartado, já existe no BD!" >> "$filelog"
				continue
			fi
		fi

		if grep -q -o "$line" "$filejogos"; then  # jogo existe? descarta!
  			printf "Jogo ${bold}${cyan}#%04d ${yellow}%02d${reset} dezenas geradas: $pink%s${red}-> foi descartado, já existe no jogo atual!${reset}\n" "$n" "$qtddezenas" "$line"
			echo "$cnow $var $line -> foi descartado, já existe no jogo atual!" >> "$filelog"
			continue
		fi

		((n++))
		printf "Jogo ${bold}${cyan}#%04d ${yellow}%02d${reset} dezenas geradas: $pink%s${green}-> foi aceito${reset}\n" "$n" "$qtddezenas" "$line"
		echo "$line" >> "$filejogos"
		echo "$cnow $var $line" >> "$filejogosformatado"
		echo "$cnow $var $line -> foi aceito" >> "$filelog"
	done
	replicate '#' 80 >> "$filejogosformatado"
	filetmp=$(mktemp)
	sort "$filejogos" > "$filetmp"; cp "$filetmp" "$filejogos"; rm "$filetmp" 2> /dev/null
}

sh_filedatetimestat(){ stat -c %w "$1"; }
sh_filedatetime(){ date -r "$1" +"%d/%m/%Y %T";}
sh_filedate(){ date -r "$1" +"%d/%m/%Y";}
sh_filetime(){ date -r "$1" +"%T"; }
sh_datetime(){ date +"%d/%m/%Y %T"; }
sh_time(){ date +"%T"; }
sh_date(){ date +"%d/%m/%Y"; }
sh_filesize(){	stat -c %s "$1"; }
sh_linecount(){ awk 'END {print NR}' "$1"; }
alltrim(){ echo "${1// /}"; } # remover todos espacos da string
len(){ echo "${#1}"; }

sh_ascii-lines()
{
	if [[ "$LANG" =~ 'UTF-8' ]]
	then
  		export NCURSES_NO_UTF8_ACS=0
	else
  		export NCURSES_NO_UTF8_ACS=1
	fi
}

sh_val()
{
	if [[ ${1} =~ ^([0-9]+)$ ]];then
		echo "N"
	elif [[ ${1} =~ ^([[:alpha:]]+)$ ]];then
		echo "C"
	else
		echo "U"
	fi
}

replicate()
{
   local Var
   printf -v Var %"$2"s " "  #  Coloca em $Var $1 espaços
   echo "${Var// /$1}"       #  Troca os espaços pelo caractere escolhido
}

die()
{
	local msg=$1; shift
	printf '%s\n' "${bold}${red}$msg${reset}" >&2
	exit 1
}

msg()
{
	local msg=$1; shift
	printf '%s\n' "${green}$msg${reset}" >&2
	return
}

erro()
{
   local msg=$1; shift
   printf '%s\n' "${bold}${yellow}$msg${reset}" >&2
   return
}

sh_checknet()
{
   # have internet?
   msg "${green}Testing internet from ${SITE}"
 	curl --insecure $SITE >/dev/null 2>&1 ||
   {
	   msg "No route to server ($SITE) - Rodando com BD sem atualizar."
	   return 1
   }
   return $?
}

setvarcolors(){
   if tput setaf 1 &> /dev/null; then
		#tput setaf 127 | cat -v  #capturar saida
      tput sgr0; # reset colors
      bold=$(tput bold);
      reset=$(tput sgr0);
      black=$(tput setaf 0);
      red=$(tput setaf 1);
      green=$(tput setaf 2);
      yellow=$(tput bold)$(tput setaf 3);
      blue=$(tput setaf 4);
      pink=$(tput setaf 5);
      cyan=$(tput setaf 6);
      white=$(tput setaf 7);
      orange=$(tput setaf 3);
      purple=$(tput setaf 125);
      violet=$(tput setaf 61);
   else
      bold='';
      reset="\e[0m";
      blue="\e[1;34m";
      cyan="\e[1;36m";
      green="\e[1;32m";
      orange="\e[1;33m";
      purple="\e[1;35m";
      red="\e[1;31m";
      violet="\e[1;35m";
      white="\e[1;37m";
      yellow="\e[1;33m";
      pink="\033[35;1m";
      black="\e[1;30m";
   fi
}

check_deps()
{
	local errorFound=0
	declare -a missing

	for d in "${DEPENDENCIES[@]}" ; {
		[[ -z $(command -v "$d") ]] && missing+=("$d") && errorFound=1 && printf '%s\n' "${red}ERRO${reset}: não encontrei o comando ${orange}'$d'${reset}"
	}
	#[[ ${#missing[@]} -ne 0 ]]
	if (( errorFound )); then
		erro "#### IMPOSSÍVEL CONTINUAR ####"
		msg "Esse script precisa dos comandos listados acima" >&2
		msg "Instale-os e/ou verifique se estão no seu \$PATH" >&2
		exit 1
	fi
}

sh_conf()
{
	read -r -p "$1 [S/n]"
	[[ ${REPLY^} == "" ]] && return $true
	[[ ${REPLY^} == "S" ]] && return $true
	[[ ${REPLY^} == N ]] && return $false
	die "ERRO: resposta deve ser S ou N"
}

sh_compare()
{
   local -i qtddezenas

	[[ ! -e "$filejogos"                 ]] && die "ERRO: nenhum jogo realizado para comparar. (use -h for help)"
	[[ $(sh_filesize "$filejogos") -eq 0 ]] && die "ERRO: nenhum jogo realizado para comparar. (use -h for help)"

	IFS=$'\n'
	#local re='[0-9]{2}[ ]?'
	local reR='([0-9]{2}[[:space:]]+)((?1))+'
	local reJ='([0-9]{2}[[:space:]]?)((?1))+'
#	local aResult=($(awk -F'-' '{ print $3 }' $fileresult))
#	local aJogos=($(awk '{print " "$0}' $filejogos))
#	local aResult=($(awk -F "$reR" 'lista[$1]++' $fileresult))
#	local aJogos=($(awk -F "$reJ" 'lista[$1]++' $filejogos))
	local aResult=($(grep -Po "$reR" "$fileresult"))
	local aJogos=($(grep -Po "$reJ" "$filejogos"))
	local n=1
	local value

:<<'vilmar'
	info "${aJogos[*]}"
	echo
	echo "${aJogos[0]}"
	echo "${aJogos[1]}"
vilmar

	for value in ${aJogos[*]}; {
	   #info "$value"
	   qtddezenas=$(( "$(len "$(alltrim "$value")")" /2 ))
	   if [[ ! "${aResult[*]}" =~ "${value}" ]]; then
			printf "Jogo ${bold}${cyan}#%04d ${yellow}%02d${reset} dezenas geradas: $pink%s${green} OK ↑ não encontrado no BD${reset}\n" "$n" $qtddezenas "$value"
	   else
			printf "Jogo ${bold}${cyan}#%04d ${yellow}%02d${reset} dezenas geradas: $pink%s${red} FALHA ↓ foi encontrado no BD${reset}\n" "$n" $qtddezenas "$value"
	   fi
	   ((n++))
	}
	IFS=$SAVEIFS
}

sh_compareREAD()
{
	local i
	[[ ! -e "$filejogos"                 ]] && die "ERRO: nenhum jogo realizado ainda para comparar. (use -h for help)"
	[[ $(sh_filesize "$filejogos") -eq 0 ]] && die "ERRO: nenhum jogo realizado ainda para comparar. (use -h for help)"

	while read -r i; do
		if grep -q -o "$i" "$fileresult"; then
			echo "$i - ${red}FALHA ↓ Já existe no BD${reset}"
		else
			echo "$i - ${green}OK ↑ não encontrado no BD${reset}"
		fi
	done < "$filejogos"
}

sh_compareGREP()
{
	#local re='[0-9]{2}[ ]?'
	local reR='([0-9]{2}[[:space:]]+)((?1))+'
	local reJ='([0-9]{2}[[:space:]]?)((?1))+'

	[[ ! -e "$filejogos"                 ]] && die "ERRO: nenhum jogo realizado ainda para comparar. (use -h for help)"
	[[ $(sh_filesize "$filejogos") -eq 0 ]] && die "ERRO: nenhum jogo realizado ainda para comparar. (use -h for help)"

	msg "Fazendo chegagem das jogadas. Aguarde..."
	if ! value=$(grep -s -o -f "$filejogos" "$fileresult"); then
		printf '%s\n' "${green}OK ↑ nenhuma jogada armazenada foi encontrada no BD${reset}"
	else
		printf '%s\n' "Jogos ${cyan}\n$value\n${red}FALHA ↓ Já existe(m) no BD${reset}"
	fi
}

sh_atualizaBDjq()
{
	contLinha=$1
   wget $SITE$contLinha --no-check-certificate -qO- > $fileUltSorteioAtualizado
	listaDezenas=$(jq -r '.listaDezenas[range(0;6)]' $fileUltSorteioAtualizado)
   dataApuracao=$(jq -r '.dataApuracao' $fileUltSorteioAtualizado)
   valorEstimadoProximoConcurso=$(jq -r '.valorEstimadoProximoConcurso' $fileUltSorteioAtualizado)
   numGanhadoresSena=$(jq -r '.listaRateioPremio[0].numeroDeGanhadores' $fileUltSorteioAtualizado)
   valorPremioSena=$(jq -r '.listaRateioPremio[0].valorPremio' $fileUltSorteioAtualizado|awk '{printf "%.2f\n" ,$1}'|sed -e :a -e 's/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta' | tr ',.' '.,')
   numGanhadoresQuina=$(jq -r '.listaRateioPremio[1].numeroDeGanhadores' $fileUltSorteioAtualizado)
   valorPremioQuina=$(jq -r '.listaRateioPremio[1].valorPremio' $fileUltSorteioAtualizado|awk '{printf "%.2f\n" ,$1}'|sed -e :a -e 's/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta' | tr ',.' '.,')
   numGanhadoresQuadra=$(jq -r '.listaRateioPremio[2].numeroDeGanhadores' $fileUltSorteioAtualizado)
   valorPremioQuadra=$(jq -r '.listaRateioPremio[2].valorPremio' $fileUltSorteioAtualizado|awk '{printf "%.2f\n" ,$1}'|sed -e :a -e 's/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta' | tr ',.' '.,')
   varLinhaInteira=$(echo $contLinha - $dataApuracao - $listaDezenas - $valorPremioSena - $numGanhadoresSena - $valorPremioQuina - $numGanhadoresQuina - $valorPremioQuadra - $numGanhadoresQuadra)
   tee -a $fileresult <<< "$varLinhaInteira"
}

sh_atualizaBD()
{
	contLinha=$1
   wget $SITE$contLinha --no-check-certificate -qO- > $fileUltSorteioAtualizado
	listaDezenas=$(sed -n '/listaDezenas/,/],/p' $fileUltSorteioAtualizado | sed 's/[^0-9]//g' | sed -e "s/\r//g" | awk -F"-" '{print $1}')
   listaDezenas=$(echo $listaDezenas | cut -c1-18)
   dataApuracao=$(grep '"dataApuracao":' $fileUltSorteioAtualizado | awk '{print $2}' | sed 's/\"//g' | sed 's/\,//g' | sed -e "s/\r//g" )
   valorEstimadoProximoConcurso=$(grep '"valorEstimadoProximoConcurso":' $fileUltSorteioAtualizado | awk -F"-" '{print $2}' | sed 's/\,//g')
   dadosSena=$(sed -n '/"faixa": 1/,/},/p' $fileUltSorteioAtualizado)
   dadosQuina=$(sed -n '/"faixa": 2/,/},/p' $fileUltSorteioAtualizado)
   dadosQuadra=$(sed -n '/"faixa": 3/,/},/p' $fileUltSorteioAtualizado)
   numGanhadoresSena=$(echo $dadosSena | awk -F'"' '{ print $5 }' | sed 's/://g' | sed 's/,//g')
   valorPremioSena=$(echo $dadosSena | awk -F'"' '{print $7}' | sed 's/://g' | sed 's/,//g')
   valorPremioSena=$(awk '{printf "%.2f\n" ,$1}' <<< "$valorPremioSena")
   valorPremioSenaFormat=$(echo $valorPremioSena  | sed -e :a -e 's/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta' | tr ',.' '.,')
   varLinhaInteira=$(echo $contLinha - $dataApuracao - $listaDezenas - $valorPremioSenaFormat - $numGanhadoresSena)
   echo $varLinhaInteira |& tee -a $fileresult
}

sh_checkresultadosfaltantes()
{
	local -i numUltSorteioGravado=$1
	local -i n=0
	local value
	local array

	msg "Checando a integridade do BD. Aguarde..."
	local array=($(awk '{ print $1 }' "$fileresult"))

	for value in $(seq "$numUltSorteioGravado")
	do
   	if [[ ! " ${array[*]} " =~ " ${value} " ]]; then
			if ! (( n )); then
				msg "Atualizando Banco de Dados. Aguarde..."
			fi
			((n++))
			if [[ -z $(command -v jq) ]]; then
				sh_atualizaBD "$value"
			else
				sh_atualizaBDjq "$value"
			fi
	   fi
	done
}

sh_update()
{
	declare -i numUltSorteio
	declare -i numUltSorteioGravado

	#### REMOVENDO ARQUIVOS TEMPORARIOS
	rm "$fileUltSorteio" 2> /dev/null
	rm "$fileUltSorteioAtualizado" 2> /dev/null

	sh_checknet || return 1
	[[ ! -e "$fileresult" ]] && :>| "$fileresult"

	#### COLETANDO DADOS DO ULTIMO RESULTADO DA MEGASENA PULICADO PELA API DA CAIXA
	wget "$SITE" --no-check-certificate -qO- > "$fileUltSorteio"
	numUltSorteio=$(awk '/["]numero["]:/ {print $2}' "$fileUltSorteio" | sed 's/\,//g' | sed '/^$/d' | sed -e "s/\r//g")

	#### COLETANDO O NUMERO DO ULTIMO SORTEIO GRAVADO NO BD
	numUltSorteioGravado=$(awk 'END {print NR}' "$fileresult")

	#### COLETANDO DADOS DOS DOS RESULTADOS NAO INCLUÍDOS NO BD
	declare -i falta=$(( numUltSorteio - numUltSorteioGravado ))
	printf "Sorteios feitos pela CAIXA : %s\n" "${red}$numUltSorteio${reset}"
	printf "Sorteios registrados no BD : %s\n" "${orange}$numUltSorteioGravado${reset}"
	msg "${falta} novo(s) registro(s) encontrado(s)!"
	sh_checkresultadosfaltantes "$numUltSorteio"
	sort -g -u "$fileresult" > "$fileresult.sort"
	cp "$fileresult.sort" "$fileresult"
	rm -f "$fileresult.sort"
	msg "OK. Banco de Dados atualizado!"

	#### REMOVENDO ARQUIVOS TEMPORARIOS
	rm $fileUltSorteio 2> /dev/null
	rm $fileUltSorteioAtualizado 2> /dev/null
}

sh_version()
{
   printf '%s' "${bold}${cyan}${0##*/} v${_VERSION_}${reset}"
}

sh_logo()
{
	sh_version
	printf '%s\n' "$bold$yellow"
	cat << 'LOGO'
   ________  ____  ____ _
  / ___/ _ \/ __ \/ __ `/
 (__  )  __/ / / / /_/ /
/____/\___/_/ /_/\__,_/
LOGO
	printf '%s' "$reset"
}

sh_listarjogos()
{
	[[ ! -e "$filejogosformatado" ]] && die "ERRO: arquivo log de jogos ainda não existe. Faça alguns jogos primeiro. (use -h for help)"
	more "$filejogosformatado"
}

choosefile()
{
   while true
   do
   	pushd "$CPATH" &>/dev/null || exit
      ARRAY_FILE_LOG=($(find *.log -type f 2>/dev/null))
      popd &>/dev/null || exit
     	[[ "${#ARRAY_FILE_LOG[@]}" -eq 0 ]] && die "ERRO: arquivo log de jogos ainda não existe. Faça alguns jogos primeiro. (use -h for help)"
      local array=()
      local i
      local n=0
      local nc=0

      for i in "${ARRAY_FILE_LOG[@]}"
      do
      	array[((n++))]="$i"
         array[((n++))]=$(printf "%-6s$sep%5s PALPITES" "$(date -r "$i" +"%d/%m/%Y %T")" "$(sh_linecount "$i")")
         ((nc++))
      done

#              --ascii-lines													               \
      sd=$(dialog                                                                \
               --clear															               \
               --title        "Arquivos de Log"							               \
               --backtitle 	"${0##*/} v${_VERSION_}"									\
               --ok-label     "Visualizar"						                     \
               --cancel-label "Sair"   									               \
               --colors                                                          \
               --extra-button                                                    \
               --extra-label  "Excluir"								                  \
               --menu         "\nArquivos Log de jogos"  			               \
               0 0 0 "${array[@]}" 2>&1 >/dev/tty  )

      exit_status=$?
      case $exit_status in
			"$D_OK")
		      if test ! -z "$sd"; then
      		   display_result "$sd"
      		fi
      		;;
         "$D_ESC"|"$D_CANCEL")
         	clear
            exit
            ;;
         3)
				sh_conf "${red}:: ${reset}Deseja excluir o arquivo $sd ?"
   			LCONF=$?
	   		if (( LCONF )); then
            	rm -f "$CPATH/$sd"
            	continue
            fi
            ;;
      esac
	done
}

sh_usage()
{
	cat <<EOF
${white}sena v$_VERSION_${reset}
${orange}uso:${reset}
   sena ${pink}-j 3${cyan}                # jogar 03 palpites (padrão 6 dezenas)${reset}
   sena ${pink}-j 10${cyan}               # jogar 10 palpites (padrão 6 dezenas)${reset}
   sena ${pink}-j 10 6${cyan}             # jogar 10 palpites com 06 (min) dezenas${reset}
   sena ${pink}-j 5 15${cyan}             # jogar 05 palpites com 15 (max) dezenas${reset}
   sena ${pink}-h|--help${cyan}           # este help${reset}
   sena ${pink}-c|--compare${cyan}        # comparar palpites com o BD${reset}
   sena ${pink}-l|--log${cyan}            # exibir log de palpites efetuados${reset}
   sena ${pink}-U|--update${cyan}         # atualizar BD com a CAIXA${reset}
   sena ${pink}-V|--version${cyan}        # exibe versão do aplicativo${reset}
EOF
}

#					--ascii-lines				               \

display_result()
{
	dialog      --title  "$1" 									\
            	--no-collapse              				\
               --no-cr-wrap               				\
               --backtitle "${0##*/} v${_VERSION_}"	\
               --textbox   "$1"           				\
               0 0
}

init()
{
   while test $# -gt 0
   do
      case "${1}" in
		   -h|-H|--help) sh_usage; exit $(( $# ? 0 : 1 ));;
   		-c|-C|--compare) sh_compare; exit $(( $# ? 0 : 1 ));;
   		-l|-L|--log) choosefile; exit $(( $# ? 0 : 1 ));;
   		-U|--update) sh_update; exit $(( $# ? 0 : 1 ));;
   		-V|--version) sh_logo; exit $(( $# ? 0 : 1 ));;
   		-j|-J|--jogo)
				shift;
   			[[ $# -lt 1 ]] && die "ERRO: requer argumento/parâmetro. (use -h for help)";
				ctype1=$(sh_val "$1");	[[ $ctype1 != "N" ]] && die "ERRO: primeiro parâmetro deve ser numérico. (use -h for help)";
   			if test $# -eq 2; then
   				ctype2=$(sh_val "$2");	[[ $ctype2 != "N" ]] && die "ERRO: segundo parâmetro deve ser numérico. (use -h for help)";
	  			fi
 				sh_playsena "$@"
 				exit $(( $# ? 0 : 1 ))
 				;;
         *)  die "operação não suportada: $1 (use -h for help)";;
      esac
      shift
   done
}

setvarcolors
check_deps
sh_ascii-lines
[[ -z $1 ]] && { sh_usage; exit $(( $# ? 0 : 1 ));}
init "$@"
# '["]listaDezenas["]:\s*[[]\s+["]\K([0-9]{2})(["],?\s+["])((?1))+(?2)+((?1))+(?2)+((?1))+(?2)+((?1))+(?2)+((?1))'
# wget https://servicebus2.caixa.gov.br/portaldeloterias/api/megasena/ --no-check-certificate -qO - | jq -r '.numero'
# jq -r '.listaDezenas[1]' temp
# grep -Po '"descricaoFaixa":.*?[^\\]",' temp
# cat temp | python -c "import json,sys;obj=json.load(sys.stdin);print(obj['listaDezenas']);"
